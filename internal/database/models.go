// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type ActivityActivityIntensity string

const (
	ActivityActivityIntensityLow    ActivityActivityIntensity = "Low"
	ActivityActivityIntensityMedium ActivityActivityIntensity = "Medium"
	ActivityActivityIntensityHigh   ActivityActivityIntensity = "High"
)

func (e *ActivityActivityIntensity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActivityActivityIntensity(s)
	case string:
		*e = ActivityActivityIntensity(s)
	default:
		return fmt.Errorf("unsupported scan type for ActivityActivityIntensity: %T", src)
	}
	return nil
}

type NullActivityActivityIntensity struct {
	ActivityActivityIntensity ActivityActivityIntensity `json:"activity_activity_intensity"`
	Valid                     bool                      `json:"valid"` // Valid is true if ActivityActivityIntensity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActivityActivityIntensity) Scan(value interface{}) error {
	if value == nil {
		ns.ActivityActivityIntensity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActivityActivityIntensity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActivityActivityIntensity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActivityActivityIntensity), nil
}

type ChatConversationsParticipant1Type string

const (
	ChatConversationsParticipant1TypeUser   ChatConversationsParticipant1Type = "user"
	ChatConversationsParticipant1TypeSeller ChatConversationsParticipant1Type = "seller"
	ChatConversationsParticipant1TypeDoctor ChatConversationsParticipant1Type = "doctor"
)

func (e *ChatConversationsParticipant1Type) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChatConversationsParticipant1Type(s)
	case string:
		*e = ChatConversationsParticipant1Type(s)
	default:
		return fmt.Errorf("unsupported scan type for ChatConversationsParticipant1Type: %T", src)
	}
	return nil
}

type NullChatConversationsParticipant1Type struct {
	ChatConversationsParticipant1Type ChatConversationsParticipant1Type `json:"chat_conversations_participant1_type"`
	Valid                             bool                              `json:"valid"` // Valid is true if ChatConversationsParticipant1Type is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChatConversationsParticipant1Type) Scan(value interface{}) error {
	if value == nil {
		ns.ChatConversationsParticipant1Type, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChatConversationsParticipant1Type.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChatConversationsParticipant1Type) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChatConversationsParticipant1Type), nil
}

type ChatConversationsParticipant2Type string

const (
	ChatConversationsParticipant2TypeUser   ChatConversationsParticipant2Type = "user"
	ChatConversationsParticipant2TypeSeller ChatConversationsParticipant2Type = "seller"
	ChatConversationsParticipant2TypeDoctor ChatConversationsParticipant2Type = "doctor"
)

func (e *ChatConversationsParticipant2Type) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChatConversationsParticipant2Type(s)
	case string:
		*e = ChatConversationsParticipant2Type(s)
	default:
		return fmt.Errorf("unsupported scan type for ChatConversationsParticipant2Type: %T", src)
	}
	return nil
}

type NullChatConversationsParticipant2Type struct {
	ChatConversationsParticipant2Type ChatConversationsParticipant2Type `json:"chat_conversations_participant2_type"`
	Valid                             bool                              `json:"valid"` // Valid is true if ChatConversationsParticipant2Type is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChatConversationsParticipant2Type) Scan(value interface{}) error {
	if value == nil {
		ns.ChatConversationsParticipant2Type, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChatConversationsParticipant2Type.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChatConversationsParticipant2Type) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChatConversationsParticipant2Type), nil
}

type ChatMessagesSenderType string

const (
	ChatMessagesSenderTypeUser   ChatMessagesSenderType = "user"
	ChatMessagesSenderTypeSeller ChatMessagesSenderType = "seller"
	ChatMessagesSenderTypeDoctor ChatMessagesSenderType = "doctor"
)

func (e *ChatMessagesSenderType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChatMessagesSenderType(s)
	case string:
		*e = ChatMessagesSenderType(s)
	default:
		return fmt.Errorf("unsupported scan type for ChatMessagesSenderType: %T", src)
	}
	return nil
}

type NullChatMessagesSenderType struct {
	ChatMessagesSenderType ChatMessagesSenderType `json:"chat_messages_sender_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if ChatMessagesSenderType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChatMessagesSenderType) Scan(value interface{}) error {
	if value == nil {
		ns.ChatMessagesSenderType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChatMessagesSenderType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChatMessagesSenderType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChatMessagesSenderType), nil
}

type DoctorAppointmentsAppointmentStatus string

const (
	DoctorAppointmentsAppointmentStatusScheduled   DoctorAppointmentsAppointmentStatus = "scheduled"
	DoctorAppointmentsAppointmentStatusConfirmed   DoctorAppointmentsAppointmentStatus = "confirmed"
	DoctorAppointmentsAppointmentStatusCompleted   DoctorAppointmentsAppointmentStatus = "completed"
	DoctorAppointmentsAppointmentStatusCancelled   DoctorAppointmentsAppointmentStatus = "cancelled"
	DoctorAppointmentsAppointmentStatusRescheduled DoctorAppointmentsAppointmentStatus = "rescheduled"
	DoctorAppointmentsAppointmentStatusNoShow      DoctorAppointmentsAppointmentStatus = "no_show"
)

func (e *DoctorAppointmentsAppointmentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DoctorAppointmentsAppointmentStatus(s)
	case string:
		*e = DoctorAppointmentsAppointmentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for DoctorAppointmentsAppointmentStatus: %T", src)
	}
	return nil
}

type NullDoctorAppointmentsAppointmentStatus struct {
	DoctorAppointmentsAppointmentStatus DoctorAppointmentsAppointmentStatus `json:"doctor_appointments_appointment_status"`
	Valid                               bool                                `json:"valid"` // Valid is true if DoctorAppointmentsAppointmentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDoctorAppointmentsAppointmentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.DoctorAppointmentsAppointmentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DoctorAppointmentsAppointmentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDoctorAppointmentsAppointmentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DoctorAppointmentsAppointmentStatus), nil
}

type DoctorAppointmentsAppointmentType string

const (
	DoctorAppointmentsAppointmentTypeVideoCall DoctorAppointmentsAppointmentType = "video_call"
	DoctorAppointmentsAppointmentTypeChat      DoctorAppointmentsAppointmentType = "chat"
	DoctorAppointmentsAppointmentTypeInPerson  DoctorAppointmentsAppointmentType = "in_person"
	DoctorAppointmentsAppointmentTypePhoneCall DoctorAppointmentsAppointmentType = "phone_call"
)

func (e *DoctorAppointmentsAppointmentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DoctorAppointmentsAppointmentType(s)
	case string:
		*e = DoctorAppointmentsAppointmentType(s)
	default:
		return fmt.Errorf("unsupported scan type for DoctorAppointmentsAppointmentType: %T", src)
	}
	return nil
}

type NullDoctorAppointmentsAppointmentType struct {
	DoctorAppointmentsAppointmentType DoctorAppointmentsAppointmentType `json:"doctor_appointments_appointment_type"`
	Valid                             bool                              `json:"valid"` // Valid is true if DoctorAppointmentsAppointmentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDoctorAppointmentsAppointmentType) Scan(value interface{}) error {
	if value == nil {
		ns.DoctorAppointmentsAppointmentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DoctorAppointmentsAppointmentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDoctorAppointmentsAppointmentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DoctorAppointmentsAppointmentType), nil
}

type SellerPromotionsPromotionType string

const (
	SellerPromotionsPromotionTypePercentage  SellerPromotionsPromotionType = "percentage"
	SellerPromotionsPromotionTypeFixedAmount SellerPromotionsPromotionType = "fixed_amount"
)

func (e *SellerPromotionsPromotionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SellerPromotionsPromotionType(s)
	case string:
		*e = SellerPromotionsPromotionType(s)
	default:
		return fmt.Errorf("unsupported scan type for SellerPromotionsPromotionType: %T", src)
	}
	return nil
}

type NullSellerPromotionsPromotionType struct {
	SellerPromotionsPromotionType SellerPromotionsPromotionType `json:"seller_promotions_promotion_type"`
	Valid                         bool                          `json:"valid"` // Valid is true if SellerPromotionsPromotionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSellerPromotionsPromotionType) Scan(value interface{}) error {
	if value == nil {
		ns.SellerPromotionsPromotionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SellerPromotionsPromotionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSellerPromotionsPromotionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SellerPromotionsPromotionType), nil
}

type SellerSellerStatus string

const (
	SellerSellerStatusActive    SellerSellerStatus = "active"
	SellerSellerStatusInactive  SellerSellerStatus = "inactive"
	SellerSellerStatusSuspended SellerSellerStatus = "suspended"
)

func (e *SellerSellerStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SellerSellerStatus(s)
	case string:
		*e = SellerSellerStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SellerSellerStatus: %T", src)
	}
	return nil
}

type NullSellerSellerStatus struct {
	SellerSellerStatus SellerSellerStatus `json:"seller_seller_status"`
	Valid              bool               `json:"valid"` // Valid is true if SellerSellerStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSellerSellerStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SellerSellerStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SellerSellerStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSellerSellerStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SellerSellerStatus), nil
}

type UserCartCartStatus string

const (
	UserCartCartStatusActive    UserCartCartStatus = "active"
	UserCartCartStatusPurchased UserCartCartStatus = "purchased"
	UserCartCartStatusDeleted   UserCartCartStatus = "deleted"
	UserCartCartStatusValue3    UserCartCartStatus = ""
)

func (e *UserCartCartStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserCartCartStatus(s)
	case string:
		*e = UserCartCartStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserCartCartStatus: %T", src)
	}
	return nil
}

type NullUserCartCartStatus struct {
	UserCartCartStatus UserCartCartStatus `json:"user_cart_cart_status"`
	Valid              bool               `json:"valid"` // Valid is true if UserCartCartStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserCartCartStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserCartCartStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserCartCartStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserCartCartStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserCartCartStatus), nil
}

type UserOrderOrderStatus string

const (
	UserOrderOrderStatusProcessing UserOrderOrderStatus = "Processing"
	UserOrderOrderStatusShipped    UserOrderOrderStatus = "Shipped"
	UserOrderOrderStatusDelivered  UserOrderOrderStatus = "Delivered"
	UserOrderOrderStatusRejected   UserOrderOrderStatus = "Rejected"
	UserOrderOrderStatusCancelled  UserOrderOrderStatus = "Cancelled"
)

func (e *UserOrderOrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserOrderOrderStatus(s)
	case string:
		*e = UserOrderOrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserOrderOrderStatus: %T", src)
	}
	return nil
}

type NullUserOrderOrderStatus struct {
	UserOrderOrderStatus UserOrderOrderStatus `json:"user_order_order_status"`
	Valid                bool                 `json:"valid"` // Valid is true if UserOrderOrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserOrderOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserOrderOrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserOrderOrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserOrderOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserOrderOrderStatus), nil
}

type UserOrderPaymentStatus string

const (
	UserOrderPaymentStatusPending UserOrderPaymentStatus = "Pending"
	UserOrderPaymentStatusPaid    UserOrderPaymentStatus = "Paid"
	UserOrderPaymentStatusFailed  UserOrderPaymentStatus = "Failed"
)

func (e *UserOrderPaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserOrderPaymentStatus(s)
	case string:
		*e = UserOrderPaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserOrderPaymentStatus: %T", src)
	}
	return nil
}

type NullUserOrderPaymentStatus struct {
	UserOrderPaymentStatus UserOrderPaymentStatus `json:"user_order_payment_status"`
	Valid                  bool                   `json:"valid"` // Valid is true if UserOrderPaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserOrderPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserOrderPaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserOrderPaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserOrderPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserOrderPaymentStatus), nil
}

type UserTransactionPaymentStatus string

const (
	UserTransactionPaymentStatusPending UserTransactionPaymentStatus = "Pending"
	UserTransactionPaymentStatusSuccess UserTransactionPaymentStatus = "Success"
	UserTransactionPaymentStatusFailed  UserTransactionPaymentStatus = "Failed"
	UserTransactionPaymentStatusExpired UserTransactionPaymentStatus = "Expired"
)

func (e *UserTransactionPaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserTransactionPaymentStatus(s)
	case string:
		*e = UserTransactionPaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserTransactionPaymentStatus: %T", src)
	}
	return nil
}

type NullUserTransactionPaymentStatus struct {
	UserTransactionPaymentStatus UserTransactionPaymentStatus `json:"user_transaction_payment_status"`
	Valid                        bool                         `json:"valid"` // Valid is true if UserTransactionPaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserTransactionPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserTransactionPaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserTransactionPaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserTransactionPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserTransactionPaymentStatus), nil
}

type UserVipVipStatus string

const (
	UserVipVipStatusPending UserVipVipStatus = "Pending"
	UserVipVipStatusActive  UserVipVipStatus = "Active"
	UserVipVipStatusExpired UserVipVipStatus = "Expired"
)

func (e *UserVipVipStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserVipVipStatus(s)
	case string:
		*e = UserVipVipStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserVipVipStatus: %T", src)
	}
	return nil
}

type NullUserVipVipStatus struct {
	UserVipVipStatus UserVipVipStatus `json:"user_vip_vip_status"`
	Valid            bool             `json:"valid"` // Valid is true if UserVipVipStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserVipVipStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserVipVipStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserVipVipStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserVipVipStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserVipVipStatus), nil
}

type UsersUserGender string

const (
	UsersUserGenderMale   UsersUserGender = "Male"
	UsersUserGenderFemale UsersUserGender = "Female"
)

func (e *UsersUserGender) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsersUserGender(s)
	case string:
		*e = UsersUserGender(s)
	default:
		return fmt.Errorf("unsupported scan type for UsersUserGender: %T", src)
	}
	return nil
}

type NullUsersUserGender struct {
	UsersUserGender UsersUserGender `json:"users_user_gender"`
	Valid           bool            `json:"valid"` // Valid is true if UsersUserGender is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsersUserGender) Scan(value interface{}) error {
	if value == nil {
		ns.UsersUserGender, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsersUserGender.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsersUserGender) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsersUserGender), nil
}

type Activity struct {
	ActivityID                string                        `json:"activity_id"`
	ActivityCategoryid        pgtype.Text                   `json:"activity_categoryid"`
	ActivityName              string                        `json:"activity_name"`
	ActivityDuration          pgtype.Int4                   `json:"activity_duration"`
	ActivityCaloriesperminute pgtype.Float8                 `json:"activity_caloriesperminute"`
	ActivityIntensity         NullActivityActivityIntensity `json:"activity_intensity"`
	ActivityInformation       pgtype.Text                   `json:"activity_information"`
	ActivityPicturepath       pgtype.Text                   `json:"activity_picturepath"`
}

type ActivityCategory struct {
	ActivityCategoryid          string      `json:"activity_categoryid"`
	ActivityCategory            pgtype.Text `json:"activity_category"`
	ActivityCategorydescription pgtype.Text `json:"activity_categorydescription"`
}

type ActivityRecommendation struct {
	RecommendationID string             `json:"recommendation_id"`
	UserID           string             `json:"user_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

type ActivityRecommendationItem struct {
	ItemID           string             `json:"item_id"`
	RecommendationID string             `json:"recommendation_id"`
	ActivityID       pgtype.Text        `json:"activity_id"`
	TimestampDate    pgtype.Timestamptz `json:"timestamp_date"`
}

type ChatConversation struct {
	ConversationID   string                            `json:"conversation_id"`
	Participant1ID   string                            `json:"participant1_id"`
	Participant1Type ChatConversationsParticipant1Type `json:"participant1_type"`
	Participant2ID   string                            `json:"participant2_id"`
	Participant2Type ChatConversationsParticipant2Type `json:"participant2_type"`
	CreatedAt        pgtype.Timestamptz                `json:"created_at"`
	LastMessageAt    pgtype.Timestamptz                `json:"last_message_at"`
}

type ChatMessage struct {
	MessageID      string                 `json:"message_id"`
	ConversationID string                 `json:"conversation_id"`
	SenderID       int64                  `json:"sender_id"`
	SenderType     ChatMessagesSenderType `json:"sender_type"`
	MessageContent string                 `json:"message_content"`
	SentAt         pgtype.Timestamptz     `json:"sent_at"`
	IsRead         pgtype.Bool            `json:"is_read"`
}

type CounterActivityRecommendationitem struct {
	CounterDate pgtype.Date `json:"counter_date"`
	Counter     pgtype.Int8 `json:"counter"`
}

type CounterActivityid struct {
	Counter int64 `json:"counter"`
}

type CounterCartid struct {
	UserID   string      `json:"user_id"`
	DateCode pgtype.Date `json:"date_code"`
	Counter  pgtype.Int8 `json:"counter"`
}

type CounterCartitemid struct {
	UserID   string      `json:"user_id"`
	DateCode pgtype.Date `json:"date_code"`
	Counter  pgtype.Int8 `json:"counter"`
}

type CounterFoodid struct {
	SellerID     string      `json:"seller_id"`
	CounterValue pgtype.Int8 `json:"counter_value"`
}

type CounterFoodrecommendationitem struct {
	UserID        string      `json:"user_id"`
	TimestampDate pgtype.Date `json:"timestamp_date"`
	Counter       pgtype.Int8 `json:"counter"`
}

type CounterGlucoseid struct {
	UserID      string      `json:"user_id"`
	CounterDate pgtype.Date `json:"counter_date"`
	Counter     pgtype.Int8 `json:"counter"`
}

type CounterHealthdataid struct {
	UserID    string      `json:"user_id"`
	DateStamp pgtype.Date `json:"date_stamp"`
	Counter   pgtype.Int8 `json:"counter"`
}

type CounterID struct {
	RegistrationDate pgtype.Date `json:"registration_date"`
	Counter          int64       `json:"counter"`
}

type CounterOrderid struct {
	UserID   string      `json:"user_id"`
	DateCode pgtype.Date `json:"date_code"`
	Counter  pgtype.Int8 `json:"counter"`
}

type CounterTransactionid struct {
	PaymentDate pgtype.Date `json:"payment_date"`
	UserID      string      `json:"user_id"`
	Counter     pgtype.Int8 `json:"counter"`
}

type DeliveryLog struct {
	LogID      int64              `json:"log_id"`
	DeliveryID int64              `json:"delivery_id"`
	LogStatus  pgtype.Text        `json:"log_status"`
	LogMessage pgtype.Text        `json:"log_message"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type DeliveryOrder struct {
	DeliveryID     int64              `json:"delivery_id"`
	OrderID        string             `json:"order_id"`
	CourierOrderid string             `json:"courier_orderid"`
	DeliveryStatus pgtype.Text        `json:"delivery_status"`
	DeliveryFee    pgtype.Int8        `json:"delivery_fee"`
	PickupAddress  pgtype.Text        `json:"pickup_address"`
	DropoffAddress pgtype.Text        `json:"dropoff_address"`
	ScheduledTime  pgtype.Timestamptz `json:"scheduled_time"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type DeliveryRecipient struct {
	RecipientID        int64          `json:"recipient_id"`
	DeliveryID         int64          `json:"delivery_id"`
	RecipientName      pgtype.Text    `json:"recipient_name"`
	RecipientPhone     pgtype.Text    `json:"recipient_phone"`
	RecipientAddress   pgtype.Text    `json:"recipient_address"`
	RecipientLatitude  pgtype.Numeric `json:"recipient_latitude"`
	RecipientLongitude pgtype.Numeric `json:"recipient_longitude"`
	RecipientNotes     pgtype.Text    `json:"recipient_notes"`
}

type Doctor struct {
	DoctorID               string      `json:"doctor_id"`
	DoctorUsername         string      `json:"doctor_username"`
	DoctorPassword         string      `json:"doctor_password"`
	DoctorFirstname        string      `json:"doctor_firstname"`
	DoctorLastname         pgtype.Text `json:"doctor_lastname"`
	DoctorEmail            string      `json:"doctor_email"`
	DoctorPhonenumber      string      `json:"doctor_phonenumber"`
	DoctorSpecialist       pgtype.Text `json:"doctor_specialist"`
	DoctorSip              pgtype.Text `json:"doctor_sip"`
	DoctorProvince         pgtype.Text `json:"doctor_province"`
	DoctorCity             pgtype.Text `json:"doctor_city"`
	DoctorDistrict         pgtype.Text `json:"doctor_district"`
	DoctorGmapslink        pgtype.Text `json:"doctor_gmapslink"`
	DoctorPracticeaddress  pgtype.Text `json:"doctor_practiceaddress"`
	DoctorPracticeschedule pgtype.Text `json:"doctor_practiceschedule"`
	DoctorAccountstatus    bool        `json:"doctor_accountstatus"`
	DoctorPhotopath        pgtype.Text `json:"doctor_photopath"`
}

type DoctorAppointment struct {
	AppointmentID       int64                               `json:"appointment_id"`
	UserID              string                              `json:"user_id"`
	DoctorID            string                              `json:"doctor_id"`
	AppointmentDatetime pgtype.Timestamptz                  `json:"appointment_datetime"`
	AppointmentStatus   DoctorAppointmentsAppointmentStatus `json:"appointment_status"`
	AppointmentType     DoctorAppointmentsAppointmentType   `json:"appointment_type"`
	AppointmentReason   pgtype.Text                         `json:"appointment_reason"`
	CreatedAt           pgtype.Timestamptz                  `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz                  `json:"updated_at"`
}

type DoctorAvailability struct {
	AvailabilityID int64       `json:"availability_id"`
	DoctorID       string      `json:"doctor_id"`
	DayOfWeek      string      `json:"day_of_week"`
	StartTime      pgtype.Time `json:"start_time"`
	EndTime        pgtype.Time `json:"end_time"`
}

type DoctorConsultationRecord struct {
	RecordID             int64              `json:"record_id"`
	AppointmentID        int64              `json:"appointment_id"`
	DoctorNotes          pgtype.Text        `json:"doctor_notes"`
	DoctorDiagnosis      pgtype.Text        `json:"doctor_diagnosis"`
	NextConsultation     pgtype.Bool        `json:"next_consultation"`
	NextConsultationDate pgtype.Date        `json:"next_consultation_date"`
	RecordedAt           pgtype.Timestamptz `json:"recorded_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type DoctorReview struct {
	ReviewID      int64              `json:"review_id"`
	DoctorID      string             `json:"doctor_id"`
	UserID        string             `json:"user_id"`
	ReviewRating  int16              `json:"review_rating"`
	ReviewComment pgtype.Text        `json:"review_comment"`
	ReviewDate    pgtype.Timestamptz `json:"review_date"`
}

type Food struct {
	FoodID           string        `json:"food_id"`
	SellerID         pgtype.Text   `json:"seller_id"`
	FoodCategoryid   string        `json:"food_categoryid"`
	FoodName         string        `json:"food_name"`
	FoodPrice        int64         `json:"food_price"`
	FoodCalories     pgtype.Int4   `json:"food_calories"`
	FoodCarbohydrate pgtype.Float8 `json:"food_carbohydrate"`
	FoodProteins     pgtype.Float8 `json:"food_proteins"`
	FoodFat          pgtype.Float8 `json:"food_fat"`
	FoodSugar        pgtype.Float8 `json:"food_sugar"`
	FoodIngredients  pgtype.Text   `json:"food_ingredients"`
	FoodDescription  pgtype.Text   `json:"food_description"`
}

type FoodCategory struct {
	FoodCategoryid string `json:"food_categoryid"`
	FoodCategory   string `json:"food_category"`
}

type FoodPicture struct {
	PhotoID              int64       `json:"photo_id"`
	FoodID               pgtype.Text `json:"food_id"`
	FoodPhotopath        pgtype.Text `json:"food_photopath"`
	FoodPhotodescription pgtype.Text `json:"food_photodescription"`
}

type FoodRecommendation struct {
	RecommendationID string             `json:"recommendation_id"`
	UserID           string             `json:"user_id"`
	GeneratedAt      pgtype.Timestamptz `json:"generated_at"`
	Notes            pgtype.Text        `json:"notes"`
	SourceAgent      pgtype.Text        `json:"source_agent"`
}

type FoodRecommendationItem struct {
	ItemID           string      `json:"item_id"`
	RecommendationID string      `json:"recommendation_id"`
	FoodID           string      `json:"food_id"`
	TimestampDate    pgtype.Date `json:"timestamp_date"`
}

type GlucoseManual struct {
	GlucoseID        string             `json:"glucose_id"`
	UserID           string             `json:"user_id"`
	GlucoseInputdate pgtype.Timestamptz `json:"glucose_inputdate"`
	GlucoseValue     float64            `json:"glucose_value"`
	GlucoseLevel     int64              `json:"glucose_level"`
}

type LogsAuth struct {
	LogID       pgtype.UUID        `json:"log_id"`
	UserID      pgtype.Text        `json:"user_id"`
	LogCategory string             `json:"log_category"`
	LogAction   string             `json:"log_action"`
	LogMessage  string             `json:"log_message"`
	LogLevel    pgtype.Text        `json:"log_level"`
	IpAddress   *netip.Addr        `json:"ip_address"`
	UserAgent   pgtype.Text        `json:"user_agent"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type MessageAttachment struct {
	AttachmentID  int64              `json:"attachment_id"`
	MessageID     string             `json:"message_id"`
	FileUrl       string             `json:"file_url"`
	FileType      string             `json:"file_type"`
	FileName      pgtype.Text        `json:"file_name"`
	FileSizeBytes pgtype.Int8        `json:"file_size_bytes"`
	UploadedAt    pgtype.Timestamptz `json:"uploaded_at"`
}

type Notification struct {
	NotificationID int64              `json:"notification_id"`
	UserID         pgtype.Text        `json:"user_id"`
	SellerID       pgtype.Text        `json:"seller_id"`
	DoctorID       pgtype.Text        `json:"doctor_id"`
	Message        string             `json:"message"`
	Type           string             `json:"type"`
	IsRead         pgtype.Bool        `json:"is_read"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Link           pgtype.Text        `json:"link"`
}

type OtpCode struct {
	OtpID               pgtype.UUID        `json:"otp_id"`
	EntityID            pgtype.UUID        `json:"entity_id"`
	EntityRole          string             `json:"entity_role"`
	OtpSecret           string             `json:"otp_secret"`
	OtpPurpose          string             `json:"otp_purpose"`
	OtpAttempts         int32              `json:"otp_attempts"`
	ExpiresAt           pgtype.Timestamptz `json:"expires_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	DeletionScheduledAt pgtype.Timestamptz `json:"deletion_scheduled_at"`
}

type PendingRegistration struct {
	PendingID      pgtype.UUID        `json:"pending_id"`
	EntityRole     string             `json:"entity_role"`
	Email          string             `json:"email"`
	Username       pgtype.Text        `json:"username"`
	HashedPassword string             `json:"hashed_password"`
	FirstName      pgtype.Text        `json:"first_name"`
	LastName       pgtype.Text        `json:"last_name"`
	RawData        []byte             `json:"raw_data"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

type Seller struct {
	SellerID           string                 `json:"seller_id"`
	SellerUsername     string                 `json:"seller_username"`
	SellerPassword     string                 `json:"seller_password"`
	SellerName         string                 `json:"seller_name"`
	SellerBusinessname string                 `json:"seller_businessname"`
	SellerEmail        string                 `json:"seller_email"`
	SellerPhonenumber  int64                  `json:"seller_phonenumber"`
	SellerProvince     pgtype.Text            `json:"seller_province"`
	SellerCity         pgtype.Text            `json:"seller_city"`
	SellerDistrict     pgtype.Text            `json:"seller_district"`
	SellerGmapslink    pgtype.Text            `json:"seller_gmapslink"`
	SellerLat          pgtype.Text            `json:"seller_lat"`
	SellerLong         pgtype.Text            `json:"seller_long"`
	SellerAddress      string                 `json:"seller_address"`
	SellerLogopath     pgtype.Text            `json:"seller_logopath"`
	SellerBannerpath   pgtype.Text            `json:"seller_bannerpath"`
	SellerJoindate     pgtype.Date            `json:"seller_joindate"`
	SellerStatus       NullSellerSellerStatus `json:"seller_status"`
}

type SellerPromotion struct {
	PromotionID         int64                         `json:"promotion_id"`
	PromotionCode       string                        `json:"promotion_code"`
	PromotionType       SellerPromotionsPromotionType `json:"promotion_type"`
	PromotionValue      int64                         `json:"promotion_value"`
	MinimumOrder        pgtype.Int8                   `json:"minimum_order"`
	StartDate           pgtype.Timestamptz            `json:"start_date"`
	EndDate             pgtype.Timestamptz            `json:"end_date"`
	UsageLimit          pgtype.Int8                   `json:"usage_limit"`
	PerUserLimit        pgtype.Int8                   `json:"per_user_limit"`
	AppliesToSellerid   pgtype.Text                   `json:"applies_to_sellerid"`
	AppliesToFoodid     pgtype.Text                   `json:"applies_to_foodid"`
	AppliesToCategoryid pgtype.Text                   `json:"applies_to_categoryid"`
	CreatedAt           pgtype.Timestamptz            `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz            `json:"updated_at"`
}

type SellerReview struct {
	ReviewID      int64       `json:"review_id"`
	SellerID      string      `json:"seller_id"`
	UserID        string      `json:"user_id"`
	ReviewRating  int16       `json:"review_rating"`
	ReviewComment pgtype.Text `json:"review_comment"`
	ReviewDate    pgtype.Date `json:"review_date"`
}

// Unified user table supporting both traditional username/password and OAuth authentication
type User struct {
	UserID string `json:"user_id"`
	// Username for traditional auth (NULL for OAuth-only users)
	UserUsername pgtype.Text `json:"user_username"`
	// Hashed password for traditional auth (NULL for OAuth-only users)
	UserPassword  pgtype.Text `json:"user_password"`
	UserFirstname pgtype.Text `json:"user_firstname"`
	UserLastname  pgtype.Text `json:"user_lastname"`
	// Primary email (used for both auth types)
	UserEmail       pgtype.Text         `json:"user_email"`
	UserDob         pgtype.Date         `json:"user_dob"`
	UserGender      NullUsersUserGender `json:"user_gender"`
	UserAccounttype pgtype.Int2         `json:"user_accounttype"`
	UserNameAuth    pgtype.Text         `json:"user_name_auth"`
	UserAvatarUrl   pgtype.Text         `json:"user_avatar_url"`
	// OAuth provider name (google, facebook, etc.) - NULL for traditional auth
	UserProvider pgtype.Text `json:"user_provider"`
	// User ID from OAuth provider - NULL for traditional auth
	UserProviderUserID pgtype.Text        `json:"user_provider_user_id"`
	UserRawData        []byte             `json:"user_raw_data"`
	UserCreatedAtAuth  pgtype.Timestamptz `json:"user_created_at_auth"`
	UserUpdatedAtAuth  pgtype.Timestamptz `json:"user_updated_at_auth"`
	UserLastLoginAt    pgtype.Timestamptz `json:"user_last_login_at"`
	// Email from OAuth provider (may differ from primary email)
	UserEmailAuth pgtype.Text `json:"user_email_auth"`
	// Whether user has verified their email via OTP
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	EmailVerifiedAt pgtype.Timestamptz `json:"email_verified_at"`
}

type UserAddress struct {
	AddressID         int64         `json:"address_id"`
	UserID            string        `json:"user_id"`
	AddressLine1      string        `json:"address_line1"`
	AddressLine2      pgtype.Text   `json:"address_line2"`
	AddressCity       string        `json:"address_city"`
	AddressProvince   pgtype.Text   `json:"address_province"`
	AddressPostalcode pgtype.Text   `json:"address_postalcode"`
	AddressLatitude   pgtype.Float8 `json:"address_latitude"`
	AddressLongitude  pgtype.Float8 `json:"address_longitude"`
	AddressLabel      pgtype.Text   `json:"address_label"`
	IsDefault         pgtype.Bool   `json:"is_default"`
}

type UserCart struct {
	CartID     string             `json:"cart_id"`
	UserID     pgtype.Text        `json:"user_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	TotalPrice pgtype.Int8        `json:"total_price"`
	CartStatus UserCartCartStatus `json:"cart_status"`
}

type UserCartitem struct {
	CartitemID string      `json:"cartitem_id"`
	CartID     pgtype.Text `json:"cart_id"`
	UserID     pgtype.Text `json:"user_id"`
	FoodID     pgtype.Text `json:"food_id"`
	FoodPrice  pgtype.Int8 `json:"food_price"`
	Quantity   int32       `json:"quantity"`
	Subtotal   pgtype.Int8 `json:"subtotal"`
}

type UserEmailChangeRequest struct {
	RequestID         pgtype.UUID        `json:"request_id"`
	UserID            string             `json:"user_id"`
	NewEmail          string             `json:"new_email"`
	VerificationToken string             `json:"verification_token"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
}

type UserHealthdatum struct {
	HealthdataID            string             `json:"healthdata_id"`
	UserID                  pgtype.Text        `json:"user_id"`
	HealthdataRecordtime    pgtype.Timestamptz `json:"healthdata_recordtime"`
	HealthdataWeight        pgtype.Numeric     `json:"healthdata_weight"`
	HealthdataHeight        pgtype.Numeric     `json:"healthdata_height"`
	HealthdataBmi           pgtype.Numeric     `json:"healthdata_bmi"`
	HealthdataBloodpressure pgtype.Text        `json:"healthdata_bloodpressure"`
	HealthdataHeartrate     pgtype.Int4        `json:"healthdata_heartrate"`
	HealthdataNotes         pgtype.Text        `json:"healthdata_notes"`
	RecordedBy              string             `json:"recorded_by"`
}

type UserOrder struct {
	OrderID           string                     `json:"order_id"`
	UserID            string                     `json:"user_id"`
	SellerID          pgtype.Text                `json:"seller_id"`
	CartID            string                     `json:"cart_id"`
	OrderDate         pgtype.Timestamptz         `json:"order_date"`
	TotalAmount       int64                      `json:"total_amount"`
	PaymentStatus     NullUserOrderPaymentStatus `json:"payment_status"`
	ShippingAddress   pgtype.Text                `json:"shipping_address"`
	OrderStatus       NullUserOrderOrderStatus   `json:"order_status"`
	OrderNotes        pgtype.Text                `json:"order_notes"`
	OrderRejectreason string                     `json:"order_rejectreason"`
}

type UserSellerfavorite struct {
	FavoriteID int64  `json:"favorite_id"`
	UserID     string `json:"user_id"`
	SellerID   string `json:"seller_id"`
}

type UserTransaction struct {
	PaymentID            string                           `json:"payment_id"`
	OrderID              string                           `json:"order_id"`
	UserID               string                           `json:"user_id"`
	PaymentMethod        pgtype.Text                      `json:"payment_method"`
	PaymentAmount        int64                            `json:"payment_amount"`
	PaymentStatus        NullUserTransactionPaymentStatus `json:"payment_status"`
	GatewayTransactionID pgtype.Text                      `json:"gateway_transaction_id"`
	GatewayResponse      pgtype.Text                      `json:"gateway_response"`
	ApprovalCode         pgtype.Text                      `json:"approval_code"`
	CreatedAt            pgtype.Timestamptz               `json:"created_at"`
	PaidAt               pgtype.Timestamptz               `json:"paid_at"`
}

type UserVip struct {
	UserID      string               `json:"user_id"`
	ActivatedAt pgtype.Timestamptz   `json:"activated_at"`
	ExpiresAt   pgtype.Timestamptz   `json:"expires_at"`
	PaymentID   pgtype.Text          `json:"payment_id"`
	Notes       pgtype.Text          `json:"notes"`
	VipStatus   NullUserVipVipStatus `json:"vip_status"`
}

type UsersAuth struct {
	ID             pgtype.UUID        `json:"id"`
	Email          string             `json:"email"`
	Name           pgtype.Text        `json:"name"`
	AvatarUrl      pgtype.Text        `json:"avatar_url"`
	Provider       string             `json:"provider"`
	ProviderUserID string             `json:"provider_user_id"`
	RawData        []byte             `json:"raw_data"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt    pgtype.Timestamptz `json:"last_login_at"`
}

type UsersRefreshToken struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            string             `json:"user_id"`
	TokenHash         string             `json:"token_hash"`
	DeviceInfo        pgtype.Text        `json:"device_info"`
	IpAddress         *netip.Addr        `json:"ip_address"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	RevokedAt         pgtype.Timestamptz `json:"revoked_at"`
	ReplacedByTokenID pgtype.UUID        `json:"replaced_by_token_id"`
}
