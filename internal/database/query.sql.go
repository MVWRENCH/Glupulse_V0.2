// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const addActivityFeedback = `-- name: AddActivityFeedback :exec
UPDATE recommended_activities
SET user_rating = $3,
    feedback = $4,
    feedback_notes = $5,
    glucose_change_after_activity = $6
WHERE session_id = $1 AND activity_id = $2
`

type AddActivityFeedbackParams struct {
	SessionID                  pgtype.UUID `json:"session_id"`
	ActivityID                 int32       `json:"activity_id"`
	UserRating                 pgtype.Int4 `json:"user_rating"`
	Feedback                   pgtype.Text `json:"feedback"`
	FeedbackNotes              pgtype.Text `json:"feedback_notes"`
	GlucoseChangeAfterActivity pgtype.Int4 `json:"glucose_change_after_activity"`
}

func (q *Queries) AddActivityFeedback(ctx context.Context, arg AddActivityFeedbackParams) error {
	_, err := q.db.Exec(ctx, addActivityFeedback,
		arg.SessionID,
		arg.ActivityID,
		arg.UserRating,
		arg.Feedback,
		arg.FeedbackNotes,
		arg.GlucoseChangeAfterActivity,
	)
	return err
}

const addFoodFeedback = `-- name: AddFoodFeedback :exec
UPDATE recommended_foods
SET user_rating = $3,
    feedback = $4,
    feedback_notes = $5,
    glucose_spike_after_eating = $6
WHERE session_id = $1 AND food_id = $2
`

type AddFoodFeedbackParams struct {
	SessionID               pgtype.UUID `json:"session_id"`
	FoodID                  pgtype.UUID `json:"food_id"`
	UserRating              pgtype.Int4 `json:"user_rating"`
	Feedback                pgtype.Text `json:"feedback"`
	FeedbackNotes           pgtype.Text `json:"feedback_notes"`
	GlucoseSpikeAfterEating pgtype.Int4 `json:"glucose_spike_after_eating"`
}

func (q *Queries) AddFoodFeedback(ctx context.Context, arg AddFoodFeedbackParams) error {
	_, err := q.db.Exec(ctx, addFoodFeedback,
		arg.SessionID,
		arg.FoodID,
		arg.UserRating,
		arg.Feedback,
		arg.FeedbackNotes,
		arg.GlucoseSpikeAfterEating,
	)
	return err
}

const addSessionFeedback = `-- name: AddSessionFeedback :exec
UPDATE recommendation_sessions
SET overall_feedback = $2,
    feedback_notes = $3
WHERE session_id = $1
`

type AddSessionFeedbackParams struct {
	SessionID       pgtype.UUID `json:"session_id"`
	OverallFeedback pgtype.Text `json:"overall_feedback"`
	FeedbackNotes   pgtype.Text `json:"feedback_notes"`
}

func (q *Queries) AddSessionFeedback(ctx context.Context, arg AddSessionFeedbackParams) error {
	_, err := q.db.Exec(ctx, addSessionFeedback, arg.SessionID, arg.OverallFeedback, arg.FeedbackNotes)
	return err
}

const assignUserRole = `-- name: AssignUserRole :exec
INSERT INTO user_roles (user_id, role_id)
SELECT $1, role_id FROM roles WHERE role_name = $2
`

type AssignUserRoleParams struct {
	UserID   string `json:"user_id"`
	RoleName string `json:"role_name"`
}

func (q *Queries) AssignUserRole(ctx context.Context, arg AssignUserRoleParams) error {
	_, err := q.db.Exec(ctx, assignUserRole, arg.UserID, arg.RoleName)
	return err
}

const checkAddressOwnership = `-- name: CheckAddressOwnership :one
SELECT EXISTS(
    SELECT 1 FROM user_addresses
    WHERE address_id = $1 AND user_id = $2 AND is_active = true
)
`

type CheckAddressOwnershipParams struct {
	AddressID pgtype.UUID `json:"address_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) CheckAddressOwnership(ctx context.Context, arg CheckAddressOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAddressOwnership, arg.AddressID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS(
    SELECT 1 FROM users WHERE user_email = $1
) AS exists
`

func (q *Queries) CheckEmailExists(ctx context.Context, userEmail pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailExists, userEmail)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsernameExists = `-- name: CheckUsernameExists :one
SELECT EXISTS(
    SELECT 1 FROM users WHERE user_username = $1
) AS exists
`

func (q *Queries) CheckUsernameExists(ctx context.Context, userUsername pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkUsernameExists, userUsername)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cleanupExpiredRefreshTokens = `-- name: CleanupExpiredRefreshTokens :exec
DELETE FROM users_refresh_tokens
WHERE expires_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) CleanupExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredRefreshTokens)
	return err
}

const cleanupRevokedRefreshTokens = `-- name: CleanupRevokedRefreshTokens :exec
DELETE FROM users_refresh_tokens
WHERE revoked_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupRevokedRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupRevokedRefreshTokens)
	return err
}

const clearCart = `-- name: ClearCart :exec
DELETE FROM user_cart_items
WHERE cart_id = $1
`

// Deletes all items from a cart
func (q *Queries) ClearCart(ctx context.Context, cartID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearCart, cartID)
	return err
}

const clearCartSeller = `-- name: ClearCartSeller :exec
UPDATE user_carts
SET seller_id = NULL
WHERE cart_id = $1
`

// This is called when the last item is removed from a cart
func (q *Queries) ClearCartSeller(ctx context.Context, cartID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearCartSeller, cartID)
	return err
}

const countActiveOTPCodes = `-- name: CountActiveOTPCodes :one
SELECT COUNT(*) FROM otp_codes
WHERE expires_at > NOW()
`

// Count OTPs that haven't expired yet
func (q *Queries) CountActiveOTPCodes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveOTPCodes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAddresses = `-- name: CountUserAddresses :one
SELECT COUNT(*) FROM user_addresses
WHERE user_id = $1 AND is_active = true
`

func (q *Queries) CountUserAddresses(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAddresses, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO user_activity_logs (
    user_id,
    activity_timestamp,
    activity_code,
    intensity,
    perceived_exertion,
    duration_minutes,
    steps_count,
    pre_activity_carbs,
    water_intake_ml,
    issue_description,
    source,
    sync_id,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING activity_id, user_id, activity_timestamp, activity_code, intensity, perceived_exertion, duration_minutes, steps_count, pre_activity_carbs, water_intake_ml, issue_description, source, sync_id, notes, created_at, updated_at
`

type CreateActivityLogParams struct {
	UserID            string             `json:"user_id"`
	ActivityTimestamp pgtype.Timestamptz `json:"activity_timestamp"`
	ActivityCode      string             `json:"activity_code"`
	Intensity         string             `json:"intensity"`
	PerceivedExertion pgtype.Int4        `json:"perceived_exertion"`
	DurationMinutes   int32              `json:"duration_minutes"`
	StepsCount        pgtype.Int4        `json:"steps_count"`
	PreActivityCarbs  pgtype.Int4        `json:"pre_activity_carbs"`
	WaterIntakeMl     pgtype.Int4        `json:"water_intake_ml"`
	IssueDescription  pgtype.Text        `json:"issue_description"`
	Source            string             `json:"source"`
	SyncID            pgtype.Text        `json:"sync_id"`
	Notes             pgtype.Text        `json:"notes"`
}

// Creates a new activity log entry
func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (UserActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.UserID,
		arg.ActivityTimestamp,
		arg.ActivityCode,
		arg.Intensity,
		arg.PerceivedExertion,
		arg.DurationMinutes,
		arg.StepsCount,
		arg.PreActivityCarbs,
		arg.WaterIntakeMl,
		arg.IssueDescription,
		arg.Source,
		arg.SyncID,
		arg.Notes,
	)
	var i UserActivityLog
	err := row.Scan(
		&i.ActivityID,
		&i.UserID,
		&i.ActivityTimestamp,
		&i.ActivityCode,
		&i.Intensity,
		&i.PerceivedExertion,
		&i.DurationMinutes,
		&i.StepsCount,
		&i.PreActivityCarbs,
		&i.WaterIntakeMl,
		&i.IssueDescription,
		&i.Source,
		&i.SyncID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAuthLog = `-- name: CreateAuthLog :one
INSERT INTO logs_auth (
    user_id,
    log_category,
    log_action,
    log_message,
    log_level,
    ip_address,
    user_agent,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at
`

type CreateAuthLogParams struct {
	UserID      pgtype.Text `json:"user_id"`
	LogCategory string      `json:"log_category"`
	LogAction   string      `json:"log_action"`
	LogMessage  string      `json:"log_message"`
	LogLevel    pgtype.Text `json:"log_level"`
	IpAddress   *netip.Addr `json:"ip_address"`
	UserAgent   pgtype.Text `json:"user_agent"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) CreateAuthLog(ctx context.Context, arg CreateAuthLogParams) (LogsAuth, error) {
	row := q.db.QueryRow(ctx, createAuthLog,
		arg.UserID,
		arg.LogCategory,
		arg.LogAction,
		arg.LogMessage,
		arg.LogLevel,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
	)
	var i LogsAuth
	err := row.Scan(
		&i.LogID,
		&i.UserID,
		&i.LogCategory,
		&i.LogAction,
		&i.LogMessage,
		&i.LogLevel,
		&i.IpAddress,
		&i.UserAgent,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createCart = `-- name: CreateCart :one
INSERT INTO user_carts (user_id)
VALUES ($1)
RETURNING cart_id, user_id, seller_id, created_at, updated_at
`

func (q *Queries) CreateCart(ctx context.Context, userID string) (UserCart, error) {
	row := q.db.QueryRow(ctx, createCart, userID)
	var i UserCart
	err := row.Scan(
		&i.CartID,
		&i.UserID,
		&i.SellerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmailChangeRequest = `-- name: CreateEmailChangeRequest :one
INSERT INTO user_email_change_requests (
    user_id,
    new_email,
    verification_token,
    expires_at
) VALUES (
    $1, $2, $3, $4
)
RETURNING request_id, user_id, new_email, verification_token, expires_at, created_at
`

type CreateEmailChangeRequestParams struct {
	UserID            string             `json:"user_id"`
	NewEmail          string             `json:"new_email"`
	VerificationToken string             `json:"verification_token"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateEmailChangeRequest(ctx context.Context, arg CreateEmailChangeRequestParams) (UserEmailChangeRequest, error) {
	row := q.db.QueryRow(ctx, createEmailChangeRequest,
		arg.UserID,
		arg.NewEmail,
		arg.VerificationToken,
		arg.ExpiresAt,
	)
	var i UserEmailChangeRequest
	err := row.Scan(
		&i.RequestID,
		&i.UserID,
		&i.NewEmail,
		&i.VerificationToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createGlucoseReading = `-- name: CreateGlucoseReading :one
INSERT INTO user_glucose_readings (
    user_id,
    glucose_value,
    reading_timestamp,
    reading_type,
    source,
    device_id,
    device_name,
    is_flagged,
    flag_reason,
    is_outlier,
    notes,
    symptoms
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING reading_id, user_id, glucose_value, reading_timestamp, reading_type, trend_arrow, rate_of_change, source, device_id, device_name, is_flagged, flag_reason, is_outlier, notes, symptoms, created_at, updated_at
`

type CreateGlucoseReadingParams struct {
	UserID           string             `json:"user_id"`
	GlucoseValue     int32              `json:"glucose_value"`
	ReadingTimestamp pgtype.Timestamptz `json:"reading_timestamp"`
	ReadingType      string             `json:"reading_type"`
	Source           pgtype.Text        `json:"source"`
	DeviceID         pgtype.Text        `json:"device_id"`
	DeviceName       pgtype.Text        `json:"device_name"`
	IsFlagged        pgtype.Bool        `json:"is_flagged"`
	FlagReason       pgtype.Text        `json:"flag_reason"`
	IsOutlier        pgtype.Bool        `json:"is_outlier"`
	Notes            pgtype.Text        `json:"notes"`
	Symptoms         []string           `json:"symptoms"`
}

func (q *Queries) CreateGlucoseReading(ctx context.Context, arg CreateGlucoseReadingParams) (UserGlucoseReading, error) {
	row := q.db.QueryRow(ctx, createGlucoseReading,
		arg.UserID,
		arg.GlucoseValue,
		arg.ReadingTimestamp,
		arg.ReadingType,
		arg.Source,
		arg.DeviceID,
		arg.DeviceName,
		arg.IsFlagged,
		arg.FlagReason,
		arg.IsOutlier,
		arg.Notes,
		arg.Symptoms,
	)
	var i UserGlucoseReading
	err := row.Scan(
		&i.ReadingID,
		&i.UserID,
		&i.GlucoseValue,
		&i.ReadingTimestamp,
		&i.ReadingType,
		&i.TrendArrow,
		&i.RateOfChange,
		&i.Source,
		&i.DeviceID,
		&i.DeviceName,
		&i.IsFlagged,
		&i.FlagReason,
		&i.IsOutlier,
		&i.Notes,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createHBA1CRecord = `-- name: CreateHBA1CRecord :one
INSERT INTO user_hba1c_records (
    user_id,
    test_date,
    hba1c_percentage,
    hba1c_mmol_mol,
    estimated_avg_glucose,
    treatment_changed,
    medication_changes,
    diet_changes,
    activity_changes,
    change_from_previous,
    trend,
    notes,
    document_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING hba1c_id, user_id, test_date, hba1c_percentage, hba1c_mmol_mol, estimated_avg_glucose, treatment_changed, medication_changes, diet_changes, activity_changes, change_from_previous, trend, notes, document_url, created_at, updated_at
`

type CreateHBA1CRecordParams struct {
	UserID              string         `json:"user_id"`
	TestDate            pgtype.Date    `json:"test_date"`
	Hba1cPercentage     pgtype.Numeric `json:"hba1c_percentage"`
	Hba1cMmolMol        pgtype.Int4    `json:"hba1c_mmol_mol"`
	EstimatedAvgGlucose pgtype.Int4    `json:"estimated_avg_glucose"`
	TreatmentChanged    pgtype.Bool    `json:"treatment_changed"`
	MedicationChanges   pgtype.Text    `json:"medication_changes"`
	DietChanges         pgtype.Text    `json:"diet_changes"`
	ActivityChanges     pgtype.Text    `json:"activity_changes"`
	ChangeFromPrevious  pgtype.Numeric `json:"change_from_previous"`
	Trend               pgtype.Text    `json:"trend"`
	Notes               pgtype.Text    `json:"notes"`
	DocumentUrl         pgtype.Text    `json:"document_url"`
}

func (q *Queries) CreateHBA1CRecord(ctx context.Context, arg CreateHBA1CRecordParams) (UserHba1cRecord, error) {
	row := q.db.QueryRow(ctx, createHBA1CRecord,
		arg.UserID,
		arg.TestDate,
		arg.Hba1cPercentage,
		arg.Hba1cMmolMol,
		arg.EstimatedAvgGlucose,
		arg.TreatmentChanged,
		arg.MedicationChanges,
		arg.DietChanges,
		arg.ActivityChanges,
		arg.ChangeFromPrevious,
		arg.Trend,
		arg.Notes,
		arg.DocumentUrl,
	)
	var i UserHba1cRecord
	err := row.Scan(
		&i.Hba1cID,
		&i.UserID,
		&i.TestDate,
		&i.Hba1cPercentage,
		&i.Hba1cMmolMol,
		&i.EstimatedAvgGlucose,
		&i.TreatmentChanged,
		&i.MedicationChanges,
		&i.DietChanges,
		&i.ActivityChanges,
		&i.ChangeFromPrevious,
		&i.Trend,
		&i.Notes,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createHealthEvent = `-- name: CreateHealthEvent :one
INSERT INTO user_health_events (
    user_id,
    event_date,
    event_type,
    severity,
    glucose_value,
    ketone_value_mmol,
    symptoms,
    treatments,
    required_medical_attention,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING event_id, user_id, event_date, event_type, severity, glucose_value, ketone_value_mmol, symptoms, treatments, required_medical_attention, notes, created_at, updated_at
`

type CreateHealthEventParams struct {
	UserID                   string         `json:"user_id"`
	EventDate                pgtype.Date    `json:"event_date"`
	EventType                string         `json:"event_type"`
	Severity                 pgtype.Text    `json:"severity"`
	GlucoseValue             pgtype.Int4    `json:"glucose_value"`
	KetoneValueMmol          pgtype.Numeric `json:"ketone_value_mmol"`
	Symptoms                 []string       `json:"symptoms"`
	Treatments               []string       `json:"treatments"`
	RequiredMedicalAttention pgtype.Bool    `json:"required_medical_attention"`
	Notes                    pgtype.Text    `json:"notes"`
}

func (q *Queries) CreateHealthEvent(ctx context.Context, arg CreateHealthEventParams) (UserHealthEvent, error) {
	row := q.db.QueryRow(ctx, createHealthEvent,
		arg.UserID,
		arg.EventDate,
		arg.EventType,
		arg.Severity,
		arg.GlucoseValue,
		arg.KetoneValueMmol,
		arg.Symptoms,
		arg.Treatments,
		arg.RequiredMedicalAttention,
		arg.Notes,
	)
	var i UserHealthEvent
	err := row.Scan(
		&i.EventID,
		&i.UserID,
		&i.EventDate,
		&i.EventType,
		&i.Severity,
		&i.GlucoseValue,
		&i.KetoneValueMmol,
		&i.Symptoms,
		&i.Treatments,
		&i.RequiredMedicalAttention,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMealItem = `-- name: CreateMealItem :one
INSERT INTO user_meal_items (
    meal_id,
    food_name,
    food_id,
    seller,
    serving_size,
    serving_size_grams,
    quantity,
    calories,
    carbs_grams,
    fiber_grams,
    protein_grams,
    fat_grams,
    sugar_grams,
    sodium_mg,
    glycemic_index,
    glycemic_load,
    food_category,
    saturated_fat_grams,
    monounsaturated_fat_grams,
    polyunsaturated_fat_grams,
    cholesterol_mg
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
)
RETURNING item_id, meal_id, food_name, food_id, seller, serving_size, serving_size_grams, quantity, calories, carbs_grams, fiber_grams, protein_grams, fat_grams, sugar_grams, sodium_mg, glycemic_index, glycemic_load, food_category, created_at, saturated_fat_grams, monounsaturated_fat_grams, polyunsaturated_fat_grams, cholesterol_mg
`

type CreateMealItemParams struct {
	MealID                  pgtype.UUID    `json:"meal_id"`
	FoodName                string         `json:"food_name"`
	FoodID                  pgtype.UUID    `json:"food_id"`
	Seller                  pgtype.Text    `json:"seller"`
	ServingSize             pgtype.Text    `json:"serving_size"`
	ServingSizeGrams        pgtype.Numeric `json:"serving_size_grams"`
	Quantity                pgtype.Numeric `json:"quantity"`
	Calories                pgtype.Int4    `json:"calories"`
	CarbsGrams              pgtype.Numeric `json:"carbs_grams"`
	FiberGrams              pgtype.Numeric `json:"fiber_grams"`
	ProteinGrams            pgtype.Numeric `json:"protein_grams"`
	FatGrams                pgtype.Numeric `json:"fat_grams"`
	SugarGrams              pgtype.Numeric `json:"sugar_grams"`
	SodiumMg                pgtype.Int4    `json:"sodium_mg"`
	GlycemicIndex           pgtype.Int4    `json:"glycemic_index"`
	GlycemicLoad            pgtype.Numeric `json:"glycemic_load"`
	FoodCategory            pgtype.Text    `json:"food_category"`
	SaturatedFatGrams       pgtype.Numeric `json:"saturated_fat_grams"`
	MonounsaturatedFatGrams pgtype.Numeric `json:"monounsaturated_fat_grams"`
	PolyunsaturatedFatGrams pgtype.Numeric `json:"polyunsaturated_fat_grams"`
	CholesterolMg           pgtype.Int4    `json:"cholesterol_mg"`
}

func (q *Queries) CreateMealItem(ctx context.Context, arg CreateMealItemParams) (UserMealItem, error) {
	row := q.db.QueryRow(ctx, createMealItem,
		arg.MealID,
		arg.FoodName,
		arg.FoodID,
		arg.Seller,
		arg.ServingSize,
		arg.ServingSizeGrams,
		arg.Quantity,
		arg.Calories,
		arg.CarbsGrams,
		arg.FiberGrams,
		arg.ProteinGrams,
		arg.FatGrams,
		arg.SugarGrams,
		arg.SodiumMg,
		arg.GlycemicIndex,
		arg.GlycemicLoad,
		arg.FoodCategory,
		arg.SaturatedFatGrams,
		arg.MonounsaturatedFatGrams,
		arg.PolyunsaturatedFatGrams,
		arg.CholesterolMg,
	)
	var i UserMealItem
	err := row.Scan(
		&i.ItemID,
		&i.MealID,
		&i.FoodName,
		&i.FoodID,
		&i.Seller,
		&i.ServingSize,
		&i.ServingSizeGrams,
		&i.Quantity,
		&i.Calories,
		&i.CarbsGrams,
		&i.FiberGrams,
		&i.ProteinGrams,
		&i.FatGrams,
		&i.SugarGrams,
		&i.SodiumMg,
		&i.GlycemicIndex,
		&i.GlycemicLoad,
		&i.FoodCategory,
		&i.CreatedAt,
		&i.SaturatedFatGrams,
		&i.MonounsaturatedFatGrams,
		&i.PolyunsaturatedFatGrams,
		&i.CholesterolMg,
	)
	return i, err
}

const createMealLog = `-- name: CreateMealLog :one
INSERT INTO user_meal_logs (
    user_id,
    meal_timestamp,
    meal_type_id,
    description,
    total_calories,
    total_carbs_grams,
    total_protein_grams,
    total_fat_grams,
    total_fiber_grams,
    total_sugar_grams,
    tags
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING meal_id, user_id, meal_timestamp, meal_type_id, description, total_calories, total_carbs_grams, total_protein_grams, total_fat_grams, total_fiber_grams, total_sugar_grams, tags, created_at, updated_at
`

type CreateMealLogParams struct {
	UserID            string             `json:"user_id"`
	MealTimestamp     pgtype.Timestamptz `json:"meal_timestamp"`
	MealTypeID        int32              `json:"meal_type_id"`
	Description       pgtype.Text        `json:"description"`
	TotalCalories     pgtype.Int4        `json:"total_calories"`
	TotalCarbsGrams   pgtype.Numeric     `json:"total_carbs_grams"`
	TotalProteinGrams pgtype.Numeric     `json:"total_protein_grams"`
	TotalFatGrams     pgtype.Numeric     `json:"total_fat_grams"`
	TotalFiberGrams   pgtype.Numeric     `json:"total_fiber_grams"`
	TotalSugarGrams   pgtype.Numeric     `json:"total_sugar_grams"`
	Tags              []string           `json:"tags"`
}

func (q *Queries) CreateMealLog(ctx context.Context, arg CreateMealLogParams) (UserMealLog, error) {
	row := q.db.QueryRow(ctx, createMealLog,
		arg.UserID,
		arg.MealTimestamp,
		arg.MealTypeID,
		arg.Description,
		arg.TotalCalories,
		arg.TotalCarbsGrams,
		arg.TotalProteinGrams,
		arg.TotalFatGrams,
		arg.TotalFiberGrams,
		arg.TotalSugarGrams,
		arg.Tags,
	)
	var i UserMealLog
	err := row.Scan(
		&i.MealID,
		&i.UserID,
		&i.MealTimestamp,
		&i.MealTypeID,
		&i.Description,
		&i.TotalCalories,
		&i.TotalCarbsGrams,
		&i.TotalProteinGrams,
		&i.TotalFatGrams,
		&i.TotalFiberGrams,
		&i.TotalSugarGrams,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMedicationLog = `-- name: CreateMedicationLog :one
INSERT INTO user_medication_logs (
    user_id,
    medication_id,
    medication_name,
    "timestamp",
    dose_amount,
    reason,
    is_pump_delivery,
    delivery_duration_minutes,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING medicationlog_id, user_id, medication_id, medication_name, timestamp, dose_amount, reason, is_pump_delivery, delivery_duration_minutes, notes, created_at, updated_at
`

type CreateMedicationLogParams struct {
	UserID                  string             `json:"user_id"`
	MedicationID            pgtype.Int4        `json:"medication_id"`
	MedicationName          string             `json:"medication_name"`
	Timestamp               pgtype.Timestamptz `json:"timestamp"`
	DoseAmount              pgtype.Numeric     `json:"dose_amount"`
	Reason                  pgtype.Text        `json:"reason"`
	IsPumpDelivery          pgtype.Bool        `json:"is_pump_delivery"`
	DeliveryDurationMinutes pgtype.Int4        `json:"delivery_duration_minutes"`
	Notes                   pgtype.Text        `json:"notes"`
}

// Logs a dose taken by the user.
func (q *Queries) CreateMedicationLog(ctx context.Context, arg CreateMedicationLogParams) (UserMedicationLog, error) {
	row := q.db.QueryRow(ctx, createMedicationLog,
		arg.UserID,
		arg.MedicationID,
		arg.MedicationName,
		arg.Timestamp,
		arg.DoseAmount,
		arg.Reason,
		arg.IsPumpDelivery,
		arg.DeliveryDurationMinutes,
		arg.Notes,
	)
	var i UserMedicationLog
	err := row.Scan(
		&i.MedicationlogID,
		&i.UserID,
		&i.MedicationID,
		&i.MedicationName,
		&i.Timestamp,
		&i.DoseAmount,
		&i.Reason,
		&i.IsPumpDelivery,
		&i.DeliveryDurationMinutes,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOTPCode = `-- name: CreateOTPCode :one
INSERT INTO otp_codes (
    entity_id,
    entity_role,
    otp_secret,
    otp_purpose,
    otp_attempts,
    expires_at,
    deletion_scheduled_at
) VALUES (
    $1, $2, $3, $4, 0, $5, $6
)
RETURNING otp_id, entity_id, entity_role, otp_secret, otp_purpose, otp_attempts, expires_at, created_at, deletion_scheduled_at
`

type CreateOTPCodeParams struct {
	EntityID            pgtype.UUID        `json:"entity_id"`
	EntityRole          string             `json:"entity_role"`
	OtpSecret           string             `json:"otp_secret"`
	OtpPurpose          string             `json:"otp_purpose"`
	ExpiresAt           pgtype.Timestamptz `json:"expires_at"`
	DeletionScheduledAt pgtype.Timestamptz `json:"deletion_scheduled_at"`
}

func (q *Queries) CreateOTPCode(ctx context.Context, arg CreateOTPCodeParams) (OtpCode, error) {
	row := q.db.QueryRow(ctx, createOTPCode,
		arg.EntityID,
		arg.EntityRole,
		arg.OtpSecret,
		arg.OtpPurpose,
		arg.ExpiresAt,
		arg.DeletionScheduledAt,
	)
	var i OtpCode
	err := row.Scan(
		&i.OtpID,
		&i.EntityID,
		&i.EntityRole,
		&i.OtpSecret,
		&i.OtpPurpose,
		&i.OtpAttempts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletionScheduledAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO user_orders (
    user_id,
    seller_id,
    total_price,
    status,
    delivery_address_json,
    payment_status,
    payment_method
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING order_id, user_id, seller_id, total_price, status, delivery_address_json, payment_status, payment_method, created_at
`

type CreateOrderParams struct {
	UserID              string         `json:"user_id"`
	SellerID            pgtype.UUID    `json:"seller_id"`
	TotalPrice          pgtype.Numeric `json:"total_price"`
	Status              string         `json:"status"`
	DeliveryAddressJson []byte         `json:"delivery_address_json"`
	PaymentStatus       string         `json:"payment_status"`
	PaymentMethod       pgtype.Text    `json:"payment_method"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (UserOrder, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.SellerID,
		arg.TotalPrice,
		arg.Status,
		arg.DeliveryAddressJson,
		arg.PaymentStatus,
		arg.PaymentMethod,
	)
	var i UserOrder
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.SellerID,
		&i.TotalPrice,
		&i.Status,
		&i.DeliveryAddressJson,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO user_order_items (
    order_id,
    food_id,
    quantity,
    price_at_purchase,
    food_name_snapshot
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING order_item_id, order_id, food_id, quantity, price_at_purchase, food_name_snapshot
`

type CreateOrderItemParams struct {
	OrderID          pgtype.UUID    `json:"order_id"`
	FoodID           pgtype.UUID    `json:"food_id"`
	Quantity         int32          `json:"quantity"`
	PriceAtPurchase  pgtype.Numeric `json:"price_at_purchase"`
	FoodNameSnapshot string         `json:"food_name_snapshot"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (UserOrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.FoodID,
		arg.Quantity,
		arg.PriceAtPurchase,
		arg.FoodNameSnapshot,
	)
	var i UserOrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.FoodID,
		&i.Quantity,
		&i.PriceAtPurchase,
		&i.FoodNameSnapshot,
	)
	return i, err
}

const createPendingRegistration = `-- name: CreatePendingRegistration :one
INSERT INTO pending_registrations
    (entity_role, email, username, hashed_password, first_name, last_name, raw_data, expires_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING pending_id
`

type CreatePendingRegistrationParams struct {
	EntityRole     string             `json:"entity_role"`
	Email          string             `json:"email"`
	Username       pgtype.Text        `json:"username"`
	HashedPassword string             `json:"hashed_password"`
	FirstName      pgtype.Text        `json:"first_name"`
	LastName       pgtype.Text        `json:"last_name"`
	RawData        []byte             `json:"raw_data"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreatePendingRegistration(ctx context.Context, arg CreatePendingRegistrationParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPendingRegistration,
		arg.EntityRole,
		arg.Email,
		arg.Username,
		arg.HashedPassword,
		arg.FirstName,
		arg.LastName,
		arg.RawData,
		arg.ExpiresAt,
	)
	var pending_id pgtype.UUID
	err := row.Scan(&pending_id)
	return pending_id, err
}

const createRecommendationSession = `-- name: CreateRecommendationSession :exec
/* ====================================================================
                     AI Recommendation Queries
==================================================================== */

INSERT INTO recommendation_sessions (
    session_id,
    user_id,
    requested_types,
    meal_type,
    food_category_codes,
    food_preferences,
    activity_type_codes,
    activity_preferences,
    insights_question,
    analysis_summary,
    insights_response,
    latest_glucose_value,
    latest_hba1c,
    user_condition_id,
    ai_model_used,
    ai_confidence_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
`

type CreateRecommendationSessionParams struct {
	SessionID           pgtype.UUID    `json:"session_id"`
	UserID              string         `json:"user_id"`
	RequestedTypes      []string       `json:"requested_types"`
	MealType            pgtype.Text    `json:"meal_type"`
	FoodCategoryCodes   []string       `json:"food_category_codes"`
	FoodPreferences     pgtype.Text    `json:"food_preferences"`
	ActivityTypeCodes   []string       `json:"activity_type_codes"`
	ActivityPreferences pgtype.Text    `json:"activity_preferences"`
	InsightsQuestion    pgtype.Text    `json:"insights_question"`
	AnalysisSummary     string         `json:"analysis_summary"`
	InsightsResponse    pgtype.Text    `json:"insights_response"`
	LatestGlucoseValue  pgtype.Int4    `json:"latest_glucose_value"`
	LatestHba1c         pgtype.Numeric `json:"latest_hba1c"`
	UserConditionID     pgtype.Int4    `json:"user_condition_id"`
	AiModelUsed         pgtype.Text    `json:"ai_model_used"`
	AiConfidenceScore   pgtype.Numeric `json:"ai_confidence_score"`
}

// Inserts a new recommendation session after AI generates recommendations. Called in storeRecommendationSession func in recommendation.go
func (q *Queries) CreateRecommendationSession(ctx context.Context, arg CreateRecommendationSessionParams) error {
	_, err := q.db.Exec(ctx, createRecommendationSession,
		arg.SessionID,
		arg.UserID,
		arg.RequestedTypes,
		arg.MealType,
		arg.FoodCategoryCodes,
		arg.FoodPreferences,
		arg.ActivityTypeCodes,
		arg.ActivityPreferences,
		arg.InsightsQuestion,
		arg.AnalysisSummary,
		arg.InsightsResponse,
		arg.LatestGlucoseValue,
		arg.LatestHba1c,
		arg.UserConditionID,
		arg.AiModelUsed,
		arg.AiConfidenceScore,
	)
	return err
}

const createRecommendedActivity = `-- name: CreateRecommendedActivity :exec
INSERT INTO recommended_activities (
    recommendation_activity_id,
    session_id,
    activity_id,
    reason,
    recommended_duration_minutes,
    recommended_intensity,
    safety_notes,
    best_time_of_day,
    glucose_management_tip,
    recommendation_rank,
    confidence_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateRecommendedActivityParams struct {
	RecommendationActivityID   pgtype.UUID    `json:"recommendation_activity_id"`
	SessionID                  pgtype.UUID    `json:"session_id"`
	ActivityID                 int32          `json:"activity_id"`
	Reason                     string         `json:"reason"`
	RecommendedDurationMinutes int32          `json:"recommended_duration_minutes"`
	RecommendedIntensity       pgtype.Text    `json:"recommended_intensity"`
	SafetyNotes                pgtype.Text    `json:"safety_notes"`
	BestTimeOfDay              pgtype.Text    `json:"best_time_of_day"`
	GlucoseManagementTip       pgtype.Text    `json:"glucose_management_tip"`
	RecommendationRank         pgtype.Int4    `json:"recommendation_rank"`
	ConfidenceScore            pgtype.Numeric `json:"confidence_score"`
}

// After AI picks activities, this stores each recommendation with reasoning. Called in processActivityRecommendations func in recommendation.go
func (q *Queries) CreateRecommendedActivity(ctx context.Context, arg CreateRecommendedActivityParams) error {
	_, err := q.db.Exec(ctx, createRecommendedActivity,
		arg.RecommendationActivityID,
		arg.SessionID,
		arg.ActivityID,
		arg.Reason,
		arg.RecommendedDurationMinutes,
		arg.RecommendedIntensity,
		arg.SafetyNotes,
		arg.BestTimeOfDay,
		arg.GlucoseManagementTip,
		arg.RecommendationRank,
		arg.ConfidenceScore,
	)
	return err
}

const createRecommendedFood = `-- name: CreateRecommendedFood :exec
INSERT INTO recommended_foods (
    recommendation_food_id,
    session_id,
    food_id,
    reason,
    nutrition_highlight,
    suggested_meal_type,
    suggested_portion_size,
    recommendation_rank,
    confidence_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
`

type CreateRecommendedFoodParams struct {
	RecommendationFoodID pgtype.UUID    `json:"recommendation_food_id"`
	SessionID            pgtype.UUID    `json:"session_id"`
	FoodID               pgtype.UUID    `json:"food_id"`
	Reason               string         `json:"reason"`
	NutritionHighlight   pgtype.Text    `json:"nutrition_highlight"`
	SuggestedMealType    pgtype.Text    `json:"suggested_meal_type"`
	SuggestedPortionSize pgtype.Text    `json:"suggested_portion_size"`
	RecommendationRank   pgtype.Int4    `json:"recommendation_rank"`
	ConfidenceScore      pgtype.Numeric `json:"confidence_score"`
}

// After AI picks foods, this stores each recommendation with reasoning. Called in processFoodRecommendations func in recommendation.go
func (q *Queries) CreateRecommendedFood(ctx context.Context, arg CreateRecommendedFoodParams) error {
	_, err := q.db.Exec(ctx, createRecommendedFood,
		arg.RecommendationFoodID,
		arg.SessionID,
		arg.FoodID,
		arg.Reason,
		arg.NutritionHighlight,
		arg.SuggestedMealType,
		arg.SuggestedPortionSize,
		arg.RecommendationRank,
		arg.ConfidenceScore,
	)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO users_refresh_tokens (
    user_id,
    token_hash,
    device_info,
    ip_address,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, token_hash, device_info, ip_address, expires_at, created_at, revoked_at, replaced_by_token_id
`

type CreateRefreshTokenParams struct {
	UserID     string             `json:"user_id"`
	TokenHash  string             `json:"token_hash"`
	DeviceInfo pgtype.Text        `json:"device_info"`
	IpAddress  *netip.Addr        `json:"ip_address"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

// Refresh Tokens (renamed table)
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (UsersRefreshToken, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.UserID,
		arg.TokenHash,
		arg.DeviceInfo,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i UsersRefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.ReplacedByTokenID,
	)
	return i, err
}

const createSleepLog = `-- name: CreateSleepLog :one
INSERT INTO user_sleep_logs (
    user_id,
    sleep_date,
    bed_time,
    wake_time,
    quality_rating,
    tracker_score,
    deep_sleep_minutes,
    rem_sleep_minutes,
    light_sleep_minutes,
    awake_minutes,
    average_hrv,
    resting_heart_rate,
    tags,
    source,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
RETURNING sleep_id, user_id, sleep_date, bed_time, wake_time, quality_rating, tracker_score, deep_sleep_minutes, rem_sleep_minutes, light_sleep_minutes, awake_minutes, average_hrv, resting_heart_rate, tags, source, notes, created_at, updated_at
`

type CreateSleepLogParams struct {
	UserID            string             `json:"user_id"`
	SleepDate         pgtype.Date        `json:"sleep_date"`
	BedTime           pgtype.Timestamptz `json:"bed_time"`
	WakeTime          pgtype.Timestamptz `json:"wake_time"`
	QualityRating     pgtype.Int4        `json:"quality_rating"`
	TrackerScore      pgtype.Int4        `json:"tracker_score"`
	DeepSleepMinutes  pgtype.Int4        `json:"deep_sleep_minutes"`
	RemSleepMinutes   pgtype.Int4        `json:"rem_sleep_minutes"`
	LightSleepMinutes pgtype.Int4        `json:"light_sleep_minutes"`
	AwakeMinutes      pgtype.Int4        `json:"awake_minutes"`
	AverageHrv        pgtype.Int4        `json:"average_hrv"`
	RestingHeartRate  pgtype.Int4        `json:"resting_heart_rate"`
	Tags              []string           `json:"tags"`
	Source            pgtype.Text        `json:"source"`
	Notes             pgtype.Text        `json:"notes"`
}

// Creates a new sleep log entry
func (q *Queries) CreateSleepLog(ctx context.Context, arg CreateSleepLogParams) (UserSleepLog, error) {
	row := q.db.QueryRow(ctx, createSleepLog,
		arg.UserID,
		arg.SleepDate,
		arg.BedTime,
		arg.WakeTime,
		arg.QualityRating,
		arg.TrackerScore,
		arg.DeepSleepMinutes,
		arg.RemSleepMinutes,
		arg.LightSleepMinutes,
		arg.AwakeMinutes,
		arg.AverageHrv,
		arg.RestingHeartRate,
		arg.Tags,
		arg.Source,
		arg.Notes,
	)
	var i UserSleepLog
	err := row.Scan(
		&i.SleepID,
		&i.UserID,
		&i.SleepDate,
		&i.BedTime,
		&i.WakeTime,
		&i.QualityRating,
		&i.TrackerScore,
		&i.DeepSleepMinutes,
		&i.RemSleepMinutes,
		&i.LightSleepMinutes,
		&i.AwakeMinutes,
		&i.AverageHrv,
		&i.RestingHeartRate,
		&i.Tags,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
/* ====================================================================
                     Authentication Queries
==================================================================== */
INSERT INTO users (
    user_id,
    user_username,
    user_password,
    user_firstname,
    user_lastname,
    user_email,
    user_dob,
    user_gender,
    user_accounttype,
    created_at,
    is_email_verified,
    email_verified_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at
`

type CreateUserParams struct {
	UserID          string              `json:"user_id"`
	UserUsername    pgtype.Text         `json:"user_username"`
	UserPassword    pgtype.Text         `json:"user_password"`
	UserFirstname   pgtype.Text         `json:"user_firstname"`
	UserLastname    pgtype.Text         `json:"user_lastname"`
	UserEmail       pgtype.Text         `json:"user_email"`
	UserDob         pgtype.Date         `json:"user_dob"`
	UserGender      NullUsersUserGender `json:"user_gender"`
	UserAccounttype pgtype.Int2         `json:"user_accounttype"`
	CreatedAt       pgtype.Timestamptz  `json:"created_at"`
	IsEmailVerified pgtype.Bool         `json:"is_email_verified"`
	EmailVerifiedAt pgtype.Timestamptz  `json:"email_verified_at"`
}

// Traditional Auth Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.UserUsername,
		arg.UserPassword,
		arg.UserFirstname,
		arg.UserLastname,
		arg.UserEmail,
		arg.UserDob,
		arg.UserGender,
		arg.UserAccounttype,
		arg.CreatedAt,
		arg.IsEmailVerified,
		arg.EmailVerifiedAt,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const createUserAddress = `-- name: CreateUserAddress :one
/* ====================================================================
                   Addresses Management Queries
==================================================================== */

INSERT INTO user_addresses (
    user_id,
    address_line1,
    address_line2,
    address_district,
    address_city,
    address_province,
    address_postalcode,
    address_latitude,
    address_longitude,
    address_label,
    recipient_name,
    recipient_phone,
    delivery_notes,
    is_default
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district
`

type CreateUserAddressParams struct {
	UserID            string        `json:"user_id"`
	AddressLine1      string        `json:"address_line1"`
	AddressLine2      pgtype.Text   `json:"address_line2"`
	AddressDistrict   pgtype.Text   `json:"address_district"`
	AddressCity       string        `json:"address_city"`
	AddressProvince   pgtype.Text   `json:"address_province"`
	AddressPostalcode pgtype.Text   `json:"address_postalcode"`
	AddressLatitude   pgtype.Float8 `json:"address_latitude"`
	AddressLongitude  pgtype.Float8 `json:"address_longitude"`
	AddressLabel      string        `json:"address_label"`
	RecipientName     pgtype.Text   `json:"recipient_name"`
	RecipientPhone    pgtype.Text   `json:"recipient_phone"`
	DeliveryNotes     pgtype.Text   `json:"delivery_notes"`
	IsDefault         bool          `json:"is_default"`
}

func (q *Queries) CreateUserAddress(ctx context.Context, arg CreateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, createUserAddress,
		arg.UserID,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.AddressDistrict,
		arg.AddressCity,
		arg.AddressProvince,
		arg.AddressPostalcode,
		arg.AddressLatitude,
		arg.AddressLongitude,
		arg.AddressLabel,
		arg.RecipientName,
		arg.RecipientPhone,
		arg.DeliveryNotes,
		arg.IsDefault,
	)
	var i UserAddress
	err := row.Scan(
		&i.AddressID,
		&i.UserID,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.AddressCity,
		&i.AddressProvince,
		&i.AddressPostalcode,
		&i.AddressLatitude,
		&i.AddressLongitude,
		&i.AddressLabel,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.DeliveryNotes,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressDistrict,
	)
	return i, err
}

const createUserMedication = `-- name: CreateUserMedication :one
INSERT INTO user_medications (
    user_id,
    display_name,
    medication_type,
    default_dose_unit
) VALUES (
    $1, $2, $3, $4
)
RETURNING medication_id, user_id, display_name, medication_type, default_dose_unit, is_active, created_at, updated_at
`

type CreateUserMedicationParams struct {
	UserID          pgtype.Text `json:"user_id"`
	DisplayName     string      `json:"display_name"`
	MedicationType  string      `json:"medication_type"`
	DefaultDoseUnit pgtype.Text `json:"default_dose_unit"`
}

// Registers a new medication configuration for the user.
func (q *Queries) CreateUserMedication(ctx context.Context, arg CreateUserMedicationParams) (UserMedication, error) {
	row := q.db.QueryRow(ctx, createUserMedication,
		arg.UserID,
		arg.DisplayName,
		arg.MedicationType,
		arg.DefaultDoseUnit,
	)
	var i UserMedication
	err := row.Scan(
		&i.MedicationID,
		&i.UserID,
		&i.DisplayName,
		&i.MedicationType,
		&i.DefaultDoseUnit,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteActivityLog = `-- name: DeleteActivityLog :exec
DELETE FROM user_activity_logs
WHERE activity_id = $1 AND user_id = $2
`

type DeleteActivityLogParams struct {
	ActivityID pgtype.UUID `json:"activity_id"`
	UserID     string      `json:"user_id"`
}

// Deletes an activity log, checking for user ownership
func (q *Queries) DeleteActivityLog(ctx context.Context, arg DeleteActivityLogParams) error {
	_, err := q.db.Exec(ctx, deleteActivityLog, arg.ActivityID, arg.UserID)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM user_cart_items
WHERE cart_id = $1 AND food_id = $2
`

type DeleteCartItemParams struct {
	CartID pgtype.UUID `json:"cart_id"`
	FoodID pgtype.UUID `json:"food_id"`
}

func (q *Queries) DeleteCartItem(ctx context.Context, arg DeleteCartItemParams) error {
	_, err := q.db.Exec(ctx, deleteCartItem, arg.CartID, arg.FoodID)
	return err
}

const deleteEmailChangeRequest = `-- name: DeleteEmailChangeRequest :exec
DELETE FROM user_email_change_requests
WHERE
    request_id = $1
`

func (q *Queries) DeleteEmailChangeRequest(ctx context.Context, requestID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEmailChangeRequest, requestID)
	return err
}

const deleteExpiredPendingRegistrations = `-- name: DeleteExpiredPendingRegistrations :exec
DELETE FROM pending_registrations
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredPendingRegistrations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPendingRegistrations)
	return err
}

const deleteGlucoseReading = `-- name: DeleteGlucoseReading :exec
DELETE FROM user_glucose_readings
WHERE reading_id = $1 AND user_id = $2
`

type DeleteGlucoseReadingParams struct {
	ReadingID pgtype.UUID `json:"reading_id"`
	UserID    string      `json:"user_id"`
}

// Deletes a reading, checking for user ownership
func (q *Queries) DeleteGlucoseReading(ctx context.Context, arg DeleteGlucoseReadingParams) error {
	_, err := q.db.Exec(ctx, deleteGlucoseReading, arg.ReadingID, arg.UserID)
	return err
}

const deleteHBA1CRecord = `-- name: DeleteHBA1CRecord :exec
DELETE FROM user_hba1c_records
WHERE hba1c_id = $1 AND user_id = $2
`

type DeleteHBA1CRecordParams struct {
	Hba1cID pgtype.UUID `json:"hba1c_id"`
	UserID  string      `json:"user_id"`
}

// Deletes a record, checking for user ownership
func (q *Queries) DeleteHBA1CRecord(ctx context.Context, arg DeleteHBA1CRecordParams) error {
	_, err := q.db.Exec(ctx, deleteHBA1CRecord, arg.Hba1cID, arg.UserID)
	return err
}

const deleteHealthEvent = `-- name: DeleteHealthEvent :exec
DELETE FROM user_health_events
WHERE event_id = $1 AND user_id = $2
`

type DeleteHealthEventParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  string      `json:"user_id"`
}

// Deletes a record, checking for user ownership
func (q *Queries) DeleteHealthEvent(ctx context.Context, arg DeleteHealthEventParams) error {
	_, err := q.db.Exec(ctx, deleteHealthEvent, arg.EventID, arg.UserID)
	return err
}

const deleteMealItemsByMealID = `-- name: DeleteMealItemsByMealID :exec
DELETE FROM user_meal_items WHERE meal_id = $1
`

func (q *Queries) DeleteMealItemsByMealID(ctx context.Context, mealID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMealItemsByMealID, mealID)
	return err
}

const deleteMealLog = `-- name: DeleteMealLog :exec
DELETE FROM user_meal_logs
WHERE meal_id = $1 AND user_id = $2
`

type DeleteMealLogParams struct {
	MealID pgtype.UUID `json:"meal_id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) DeleteMealLog(ctx context.Context, arg DeleteMealLogParams) error {
	_, err := q.db.Exec(ctx, deleteMealLog, arg.MealID, arg.UserID)
	return err
}

const deleteMedicationLog = `-- name: DeleteMedicationLog :exec
DELETE FROM user_medication_logs
WHERE medicationlog_id = $1 AND user_id = $2
`

type DeleteMedicationLogParams struct {
	MedicationlogID pgtype.UUID `json:"medicationlog_id"`
	UserID          string      `json:"user_id"`
}

// Deletes a single dose log.
func (q *Queries) DeleteMedicationLog(ctx context.Context, arg DeleteMedicationLogParams) error {
	_, err := q.db.Exec(ctx, deleteMedicationLog, arg.MedicationlogID, arg.UserID)
	return err
}

const deleteOTPCode = `-- name: DeleteOTPCode :exec
DELETE FROM otp_codes
WHERE otp_id = $1
`

func (q *Queries) DeleteOTPCode(ctx context.Context, otpID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOTPCode, otpID)
	return err
}

const deleteOTPCodeByEntityID = `-- name: DeleteOTPCodeByEntityID :exec
DELETE FROM otp_codes
WHERE entity_id = $1
`

func (q *Queries) DeleteOTPCodeByEntityID(ctx context.Context, entityID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOTPCodeByEntityID, entityID)
	return err
}

const deleteOldAuthLogs = `-- name: DeleteOldAuthLogs :exec
DELETE FROM logs_auth
WHERE created_at < $1
`

func (q *Queries) DeleteOldAuthLogs(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldAuthLogs, createdAt)
	return err
}

const deletePendingRegistration = `-- name: DeletePendingRegistration :exec
DELETE FROM pending_registrations
WHERE pending_id = $1
`

func (q *Queries) DeletePendingRegistration(ctx context.Context, pendingID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePendingRegistration, pendingID)
	return err
}

const deleteScheduledOTPCodes = `-- name: DeleteScheduledOTPCodes :exec
DELETE FROM otp_codes
WHERE deletion_scheduled_at IS NOT NULL 
AND deletion_scheduled_at <= NOW()
`

// Delete OTPs that are scheduled for deletion and time has passed
func (q *Queries) DeleteScheduledOTPCodes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteScheduledOTPCodes)
	return err
}

const deleteSleepLog = `-- name: DeleteSleepLog :exec
DELETE FROM user_sleep_logs
WHERE sleep_id = $1 AND user_id = $2
`

type DeleteSleepLogParams struct {
	SleepID pgtype.UUID `json:"sleep_id"`
	UserID  string      `json:"user_id"`
}

// Deletes a sleep log, checking for user ownership
func (q *Queries) DeleteSleepLog(ctx context.Context, arg DeleteSleepLogParams) error {
	_, err := q.db.Exec(ctx, deleteSleepLog, arg.SleepID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const deleteUserAddress = `-- name: DeleteUserAddress :exec
UPDATE user_addresses
SET is_active = false, is_default = false
WHERE address_id = $1 AND user_id = $2
`

type DeleteUserAddressParams struct {
	AddressID pgtype.UUID `json:"address_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) DeleteUserAddress(ctx context.Context, arg DeleteUserAddressParams) error {
	_, err := q.db.Exec(ctx, deleteUserAddress, arg.AddressID, arg.UserID)
	return err
}

const deleteUserHealthProfile = `-- name: DeleteUserHealthProfile :exec
DELETE FROM user_health_profiles
WHERE user_id = $1
`

func (q *Queries) DeleteUserHealthProfile(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteUserHealthProfile, userID)
	return err
}

const deleteUserMedication = `-- name: DeleteUserMedication :exec
UPDATE user_medications
SET is_active = false
WHERE medication_id = $1 AND user_id = $2
`

type DeleteUserMedicationParams struct {
	MedicationID int32       `json:"medication_id"`
	UserID       pgtype.Text `json:"user_id"`
}

// Soft deletes the medication configuration (sets is_active = false).
func (q *Queries) DeleteUserMedication(ctx context.Context, arg DeleteUserMedicationParams) error {
	_, err := q.db.Exec(ctx, deleteUserMedication, arg.MedicationID, arg.UserID)
	return err
}

const expireRecommendationSession = `-- name: ExpireRecommendationSession :exec
UPDATE recommendation_sessions
SET expires_at = NOW()
WHERE session_id = $1
`

func (q *Queries) ExpireRecommendationSession(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, expireRecommendationSession, sessionID)
	return err
}

const getActivityLogByID = `-- name: GetActivityLogByID :one
SELECT activity_id, user_id, activity_timestamp, activity_code, intensity, perceived_exertion, duration_minutes, steps_count, pre_activity_carbs, water_intake_ml, issue_description, source, sync_id, notes, created_at, updated_at FROM user_activity_logs
WHERE activity_id = $1 AND user_id = $2
`

type GetActivityLogByIDParams struct {
	ActivityID pgtype.UUID `json:"activity_id"`
	UserID     string      `json:"user_id"`
}

// Retrieves a single activity log, checking for user ownership
func (q *Queries) GetActivityLogByID(ctx context.Context, arg GetActivityLogByIDParams) (UserActivityLog, error) {
	row := q.db.QueryRow(ctx, getActivityLogByID, arg.ActivityID, arg.UserID)
	var i UserActivityLog
	err := row.Scan(
		&i.ActivityID,
		&i.UserID,
		&i.ActivityTimestamp,
		&i.ActivityCode,
		&i.Intensity,
		&i.PerceivedExertion,
		&i.DurationMinutes,
		&i.StepsCount,
		&i.PreActivityCarbs,
		&i.WaterIntakeMl,
		&i.IssueDescription,
		&i.Source,
		&i.SyncID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivityLogs = `-- name: GetActivityLogs :many
SELECT activity_id, user_id, activity_timestamp, activity_code, intensity, perceived_exertion, duration_minutes, steps_count, pre_activity_carbs, water_intake_ml, issue_description, source, sync_id, notes, created_at, updated_at FROM user_activity_logs
WHERE user_id = $1
  AND activity_timestamp >= COALESCE($2, '1900-01-01'::timestamptz)
  AND activity_timestamp <= COALESCE($3, NOW() + INTERVAL '1 day')
ORDER BY activity_timestamp DESC
`

type GetActivityLogsParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Retrieves all activity logs for the user, ordered newest first, with optional date range
func (q *Queries) GetActivityLogs(ctx context.Context, arg GetActivityLogsParams) ([]UserActivityLog, error) {
	rows, err := q.db.Query(ctx, getActivityLogs, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserActivityLog
	for rows.Next() {
		var i UserActivityLog
		if err := rows.Scan(
			&i.ActivityID,
			&i.UserID,
			&i.ActivityTimestamp,
			&i.ActivityCode,
			&i.Intensity,
			&i.PerceivedExertion,
			&i.DurationMinutes,
			&i.StepsCount,
			&i.PreActivityCarbs,
			&i.WaterIntakeMl,
			&i.IssueDescription,
			&i.Source,
			&i.SyncID,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityTypes = `-- name: GetActivityTypes :many
SELECT activity_type_id, activity_code, display_name, intensity_level FROM activity_types
ORDER BY display_name
`

// Retrieves all activity types, ordered by display name
func (q *Queries) GetActivityTypes(ctx context.Context) ([]ActivityType, error) {
	rows, err := q.db.Query(ctx, getActivityTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityType
	for rows.Next() {
		var i ActivityType
		if err := rows.Scan(
			&i.ActivityTypeID,
			&i.ActivityCode,
			&i.DisplayName,
			&i.IntensityLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthLogsByCategory = `-- name: GetAuthLogsByCategory :many
SELECT log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at FROM logs_auth
WHERE log_category = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuthLogsByCategoryParams struct {
	LogCategory string `json:"log_category"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) GetAuthLogsByCategory(ctx context.Context, arg GetAuthLogsByCategoryParams) ([]LogsAuth, error) {
	rows, err := q.db.Query(ctx, getAuthLogsByCategory, arg.LogCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogsAuth
	for rows.Next() {
		var i LogsAuth
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.LogCategory,
			&i.LogAction,
			&i.LogMessage,
			&i.LogLevel,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthLogsByDateRange = `-- name: GetAuthLogsByDateRange :many
SELECT log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at FROM logs_auth
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetAuthLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetAuthLogsByDateRange(ctx context.Context, arg GetAuthLogsByDateRangeParams) ([]LogsAuth, error) {
	rows, err := q.db.Query(ctx, getAuthLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogsAuth
	for rows.Next() {
		var i LogsAuth
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.LogCategory,
			&i.LogAction,
			&i.LogMessage,
			&i.LogLevel,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthLogsByUserID = `-- name: GetAuthLogsByUserID :many
SELECT log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at FROM logs_auth
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuthLogsByUserIDParams struct {
	UserID pgtype.Text `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetAuthLogsByUserID(ctx context.Context, arg GetAuthLogsByUserIDParams) ([]LogsAuth, error) {
	rows, err := q.db.Query(ctx, getAuthLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogsAuth
	for rows.Next() {
		var i LogsAuth
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.LogCategory,
			&i.LogAction,
			&i.LogMessage,
			&i.LogLevel,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCartByUserID = `-- name: GetCartByUserID :one
/* ====================================================================
                   Cart & Order Management Queries
==================================================================== */

SELECT cart_id, user_id, seller_id, created_at, updated_at FROM user_carts
WHERE user_id = $1
`

func (q *Queries) GetCartByUserID(ctx context.Context, userID string) (UserCart, error) {
	row := q.db.QueryRow(ctx, getCartByUserID, userID)
	var i UserCart
	err := row.Scan(
		&i.CartID,
		&i.UserID,
		&i.SellerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCartItems = `-- name: GetCartItems :many
SELECT 
    ci.cart_item_id, ci.cart_id, ci.food_id, ci.quantity,
    f.food_name,
    f.price,
    f.photo_url,
    f.seller_id
FROM user_cart_items ci
JOIN foods f ON ci.food_id = f.food_id
WHERE ci.cart_id = $1
`

type GetCartItemsRow struct {
	CartItemID pgtype.UUID    `json:"cart_item_id"`
	CartID     pgtype.UUID    `json:"cart_id"`
	FoodID     pgtype.UUID    `json:"food_id"`
	Quantity   int32          `json:"quantity"`
	FoodName   string         `json:"food_name"`
	Price      pgtype.Numeric `json:"price"`
	PhotoUrl   pgtype.Text    `json:"photo_url"`
	SellerID   pgtype.UUID    `json:"seller_id"`
}

func (q *Queries) GetCartItems(ctx context.Context, cartID pgtype.UUID) ([]GetCartItemsRow, error) {
	rows, err := q.db.Query(ctx, getCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCartItemsRow
	for rows.Next() {
		var i GetCartItemsRow
		if err := rows.Scan(
			&i.CartItemID,
			&i.CartID,
			&i.FoodID,
			&i.Quantity,
			&i.FoodName,
			&i.Price,
			&i.PhotoUrl,
			&i.SellerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultAddress = `-- name: GetDefaultAddress :one
SELECT address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district FROM user_addresses
WHERE user_id = $1 AND is_default = true AND is_active = true
LIMIT 1
`

func (q *Queries) GetDefaultAddress(ctx context.Context, userID string) (UserAddress, error) {
	row := q.db.QueryRow(ctx, getDefaultAddress, userID)
	var i UserAddress
	err := row.Scan(
		&i.AddressID,
		&i.UserID,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.AddressCity,
		&i.AddressProvince,
		&i.AddressPostalcode,
		&i.AddressLatitude,
		&i.AddressLongitude,
		&i.AddressLabel,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.DeliveryNotes,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressDistrict,
	)
	return i, err
}

const getEmailChangeRequestByToken = `-- name: GetEmailChangeRequestByToken :one
SELECT request_id, user_id, new_email, verification_token, expires_at, created_at
FROM user_email_change_requests
WHERE
    verification_token = $1
`

func (q *Queries) GetEmailChangeRequestByToken(ctx context.Context, verificationToken string) (UserEmailChangeRequest, error) {
	row := q.db.QueryRow(ctx, getEmailChangeRequestByToken, verificationToken)
	var i UserEmailChangeRequest
	err := row.Scan(
		&i.RequestID,
		&i.UserID,
		&i.NewEmail,
		&i.VerificationToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getFailedLoginAttempts = `-- name: GetFailedLoginAttempts :many
SELECT log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at FROM logs_auth
WHERE log_category = 'login'
  AND log_action = 'login_failed'
  AND created_at > $1
ORDER BY created_at DESC
`

func (q *Queries) GetFailedLoginAttempts(ctx context.Context, createdAt pgtype.Timestamptz) ([]LogsAuth, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttempts, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogsAuth
	for rows.Next() {
		var i LogsAuth
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.LogCategory,
			&i.LogAction,
			&i.LogMessage,
			&i.LogLevel,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFood = `-- name: GetFood :one
SELECT food_id, seller_id, food_name, description, price, currency, photo_url, thumbnail_url, is_available, stock_count, tags, created_at, updated_at, serving_size, serving_size_grams, quantity, calories, carbs_grams, fiber_grams, protein_grams, fat_grams, sugar_grams, sodium_mg, glycemic_index, glycemic_load, food_category, saturated_fat_grams, monounsaturated_fat_grams, polyunsaturated_fat_grams, cholesterol_mg FROM foods
WHERE food_id = $1
`

func (q *Queries) GetFood(ctx context.Context, foodID pgtype.UUID) (Food, error) {
	row := q.db.QueryRow(ctx, getFood, foodID)
	var i Food
	err := row.Scan(
		&i.FoodID,
		&i.SellerID,
		&i.FoodName,
		&i.Description,
		&i.Price,
		&i.Currency,
		&i.PhotoUrl,
		&i.ThumbnailUrl,
		&i.IsAvailable,
		&i.StockCount,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServingSize,
		&i.ServingSizeGrams,
		&i.Quantity,
		&i.Calories,
		&i.CarbsGrams,
		&i.FiberGrams,
		&i.ProteinGrams,
		&i.FatGrams,
		&i.SugarGrams,
		&i.SodiumMg,
		&i.GlycemicIndex,
		&i.GlycemicLoad,
		&i.FoodCategory,
		&i.SaturatedFatGrams,
		&i.MonounsaturatedFatGrams,
		&i.PolyunsaturatedFatGrams,
		&i.CholesterolMg,
	)
	return i, err
}

const getFoodForUpdate = `-- name: GetFoodForUpdate :one
SELECT food_id, food_name, price, stock_count, is_available FROM foods
WHERE food_id = $1
FOR UPDATE
`

type GetFoodForUpdateRow struct {
	FoodID      pgtype.UUID    `json:"food_id"`
	FoodName    string         `json:"food_name"`
	Price       pgtype.Numeric `json:"price"`
	StockCount  pgtype.Int4    `json:"stock_count"`
	IsAvailable pgtype.Bool    `json:"is_available"`
}

// Locks the food row to check stock during a transaction
func (q *Queries) GetFoodForUpdate(ctx context.Context, foodID pgtype.UUID) (GetFoodForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getFoodForUpdate, foodID)
	var i GetFoodForUpdateRow
	err := row.Scan(
		&i.FoodID,
		&i.FoodName,
		&i.Price,
		&i.StockCount,
		&i.IsAvailable,
	)
	return i, err
}

const getGlucoseReadingByID = `-- name: GetGlucoseReadingByID :one
SELECT reading_id, user_id, glucose_value, reading_timestamp, reading_type, trend_arrow, rate_of_change, source, device_id, device_name, is_flagged, flag_reason, is_outlier, notes, symptoms, created_at, updated_at FROM user_glucose_readings
WHERE reading_id = $1 AND user_id = $2
`

type GetGlucoseReadingByIDParams struct {
	ReadingID pgtype.UUID `json:"reading_id"`
	UserID    string      `json:"user_id"`
}

// Retrieves a single reading, checking for user ownership
func (q *Queries) GetGlucoseReadingByID(ctx context.Context, arg GetGlucoseReadingByIDParams) (UserGlucoseReading, error) {
	row := q.db.QueryRow(ctx, getGlucoseReadingByID, arg.ReadingID, arg.UserID)
	var i UserGlucoseReading
	err := row.Scan(
		&i.ReadingID,
		&i.UserID,
		&i.GlucoseValue,
		&i.ReadingTimestamp,
		&i.ReadingType,
		&i.TrendArrow,
		&i.RateOfChange,
		&i.Source,
		&i.DeviceID,
		&i.DeviceName,
		&i.IsFlagged,
		&i.FlagReason,
		&i.IsOutlier,
		&i.Notes,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGlucoseReadings = `-- name: GetGlucoseReadings :many
SELECT reading_id, user_id, glucose_value, reading_timestamp, reading_type, trend_arrow, rate_of_change, source, device_id, device_name, is_flagged, flag_reason, is_outlier, notes, symptoms, created_at, updated_at FROM user_glucose_readings
WHERE user_id = $1 
  AND reading_timestamp >= COALESCE($2, '1900-01-01'::timestamptz)
  AND reading_timestamp <= COALESCE($3, NOW() + INTERVAL '1 day')
ORDER BY reading_timestamp DESC
`

type GetGlucoseReadingsParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Retrieves all readings for the user, ordered newest first, with optional date range
func (q *Queries) GetGlucoseReadings(ctx context.Context, arg GetGlucoseReadingsParams) ([]UserGlucoseReading, error) {
	rows, err := q.db.Query(ctx, getGlucoseReadings, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserGlucoseReading
	for rows.Next() {
		var i UserGlucoseReading
		if err := rows.Scan(
			&i.ReadingID,
			&i.UserID,
			&i.GlucoseValue,
			&i.ReadingTimestamp,
			&i.ReadingType,
			&i.TrendArrow,
			&i.RateOfChange,
			&i.Source,
			&i.DeviceID,
			&i.DeviceName,
			&i.IsFlagged,
			&i.FlagReason,
			&i.IsOutlier,
			&i.Notes,
			&i.Symptoms,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlucoseStats = `-- name: GetGlucoseStats :one
SELECT 
    AVG(glucose_value) AS mean_glucose,
    STDDEV(glucose_value) AS stddev_glucose
FROM user_glucose_readings
WHERE user_id = $1 
  AND reading_timestamp >= NOW() - INTERVAL '7 days'
`

type GetGlucoseStatsRow struct {
	MeanGlucose   float64 `json:"mean_glucose"`
	StddevGlucose float64 `json:"stddev_glucose"`
}

// Retrieves the mean and standard deviation of glucose readings
// over the last 7 days for outlier analysis.
func (q *Queries) GetGlucoseStats(ctx context.Context, userID string) (GetGlucoseStatsRow, error) {
	row := q.db.QueryRow(ctx, getGlucoseStats, userID)
	var i GetGlucoseStatsRow
	err := row.Scan(&i.MeanGlucose, &i.StddevGlucose)
	return i, err
}

const getHBA1CRecordByID = `-- name: GetHBA1CRecordByID :one
SELECT hba1c_id, user_id, test_date, hba1c_percentage, hba1c_mmol_mol, estimated_avg_glucose, treatment_changed, medication_changes, diet_changes, activity_changes, change_from_previous, trend, notes, document_url, created_at, updated_at FROM user_hba1c_records
WHERE hba1c_id = $1 AND user_id = $2
`

type GetHBA1CRecordByIDParams struct {
	Hba1cID pgtype.UUID `json:"hba1c_id"`
	UserID  string      `json:"user_id"`
}

// Retrieves a single record, checking for user ownership
func (q *Queries) GetHBA1CRecordByID(ctx context.Context, arg GetHBA1CRecordByIDParams) (UserHba1cRecord, error) {
	row := q.db.QueryRow(ctx, getHBA1CRecordByID, arg.Hba1cID, arg.UserID)
	var i UserHba1cRecord
	err := row.Scan(
		&i.Hba1cID,
		&i.UserID,
		&i.TestDate,
		&i.Hba1cPercentage,
		&i.Hba1cMmolMol,
		&i.EstimatedAvgGlucose,
		&i.TreatmentChanged,
		&i.MedicationChanges,
		&i.DietChanges,
		&i.ActivityChanges,
		&i.ChangeFromPrevious,
		&i.Trend,
		&i.Notes,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHBA1CRecords = `-- name: GetHBA1CRecords :many
SELECT hba1c_id, user_id, test_date, hba1c_percentage, hba1c_mmol_mol, estimated_avg_glucose, treatment_changed, medication_changes, diet_changes, activity_changes, change_from_previous, trend, notes, document_url, created_at, updated_at FROM user_hba1c_records
WHERE user_id = $1
ORDER BY test_date DESC, created_at DESC
`

// Retrieves all records for the user, ordered newest first
func (q *Queries) GetHBA1CRecords(ctx context.Context, userID string) ([]UserHba1cRecord, error) {
	rows, err := q.db.Query(ctx, getHBA1CRecords, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserHba1cRecord
	for rows.Next() {
		var i UserHba1cRecord
		if err := rows.Scan(
			&i.Hba1cID,
			&i.UserID,
			&i.TestDate,
			&i.Hba1cPercentage,
			&i.Hba1cMmolMol,
			&i.EstimatedAvgGlucose,
			&i.TreatmentChanged,
			&i.MedicationChanges,
			&i.DietChanges,
			&i.ActivityChanges,
			&i.ChangeFromPrevious,
			&i.Trend,
			&i.Notes,
			&i.DocumentUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHealthEventByID = `-- name: GetHealthEventByID :one
SELECT event_id, user_id, event_date, event_type, severity, glucose_value, ketone_value_mmol, symptoms, treatments, required_medical_attention, notes, created_at, updated_at FROM user_health_events
WHERE event_id = $1 AND user_id = $2
`

type GetHealthEventByIDParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  string      `json:"user_id"`
}

// Retrieves a single event, checking for user ownership
func (q *Queries) GetHealthEventByID(ctx context.Context, arg GetHealthEventByIDParams) (UserHealthEvent, error) {
	row := q.db.QueryRow(ctx, getHealthEventByID, arg.EventID, arg.UserID)
	var i UserHealthEvent
	err := row.Scan(
		&i.EventID,
		&i.UserID,
		&i.EventDate,
		&i.EventType,
		&i.Severity,
		&i.GlucoseValue,
		&i.KetoneValueMmol,
		&i.Symptoms,
		&i.Treatments,
		&i.RequiredMedicalAttention,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHealthEvents = `-- name: GetHealthEvents :many
SELECT event_id, user_id, event_date, event_type, severity, glucose_value, ketone_value_mmol, symptoms, treatments, required_medical_attention, notes, created_at, updated_at FROM user_health_events
WHERE user_id = $1
ORDER BY event_date DESC, created_at DESC
`

// Retrieves all health events for the user, ordered newest first
func (q *Queries) GetHealthEvents(ctx context.Context, userID string) ([]UserHealthEvent, error) {
	rows, err := q.db.Query(ctx, getHealthEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserHealthEvent
	for rows.Next() {
		var i UserHealthEvent
		if err := rows.Scan(
			&i.EventID,
			&i.UserID,
			&i.EventDate,
			&i.EventType,
			&i.Severity,
			&i.GlucoseValue,
			&i.KetoneValueMmol,
			&i.Symptoms,
			&i.Treatments,
			&i.RequiredMedicalAttention,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastHBA1CRecord = `-- name: GetLastHBA1CRecord :one
SELECT hba1c_percentage FROM user_hba1c_records
WHERE user_id = $1 
  AND test_date < $2 -- CRITICAL: Only look at records older than the current one
ORDER BY test_date DESC, created_at DESC
LIMIT 1
`

type GetLastHBA1CRecordParams struct {
	UserID   string      `json:"user_id"`
	TestDate pgtype.Date `json:"test_date"`
}

// Retrieves the most recent record to compare against for trend analysis
func (q *Queries) GetLastHBA1CRecord(ctx context.Context, arg GetLastHBA1CRecordParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getLastHBA1CRecord, arg.UserID, arg.TestDate)
	var hba1c_percentage pgtype.Numeric
	err := row.Scan(&hba1c_percentage)
	return hba1c_percentage, err
}

const getLatestGlucoseReading = `-- name: GetLatestGlucoseReading :one
SELECT reading_id, user_id, glucose_value, reading_timestamp, reading_type, trend_arrow, rate_of_change, source, device_id, device_name, is_flagged, flag_reason, is_outlier, notes, symptoms, created_at, updated_at FROM user_glucose_readings
WHERE user_id = $1
ORDER BY reading_timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestGlucoseReading(ctx context.Context, userID string) (UserGlucoseReading, error) {
	row := q.db.QueryRow(ctx, getLatestGlucoseReading, userID)
	var i UserGlucoseReading
	err := row.Scan(
		&i.ReadingID,
		&i.UserID,
		&i.GlucoseValue,
		&i.ReadingTimestamp,
		&i.ReadingType,
		&i.TrendArrow,
		&i.RateOfChange,
		&i.Source,
		&i.DeviceID,
		&i.DeviceName,
		&i.IsFlagged,
		&i.FlagReason,
		&i.IsOutlier,
		&i.Notes,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestHBA1CRecord = `-- name: GetLatestHBA1CRecord :one
SELECT hba1c_id, user_id, test_date, hba1c_percentage, hba1c_mmol_mol, estimated_avg_glucose, treatment_changed, medication_changes, diet_changes, activity_changes, change_from_previous, trend, notes, document_url, created_at, updated_at FROM user_hba1c_records
WHERE user_id = $1
ORDER BY test_date DESC
LIMIT 1
`

func (q *Queries) GetLatestHBA1CRecord(ctx context.Context, userID string) (UserHba1cRecord, error) {
	row := q.db.QueryRow(ctx, getLatestHBA1CRecord, userID)
	var i UserHba1cRecord
	err := row.Scan(
		&i.Hba1cID,
		&i.UserID,
		&i.TestDate,
		&i.Hba1cPercentage,
		&i.Hba1cMmolMol,
		&i.EstimatedAvgGlucose,
		&i.TreatmentChanged,
		&i.MedicationChanges,
		&i.DietChanges,
		&i.ActivityChanges,
		&i.ChangeFromPrevious,
		&i.Trend,
		&i.Notes,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMealItemsByMealID = `-- name: GetMealItemsByMealID :many
SELECT item_id, meal_id, food_name, food_id, seller, serving_size, serving_size_grams, quantity, calories, carbs_grams, fiber_grams, protein_grams, fat_grams, sugar_grams, sodium_mg, glycemic_index, glycemic_load, food_category, created_at, saturated_fat_grams, monounsaturated_fat_grams, polyunsaturated_fat_grams, cholesterol_mg FROM user_meal_items
WHERE meal_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetMealItemsByMealID(ctx context.Context, mealID pgtype.UUID) ([]UserMealItem, error) {
	rows, err := q.db.Query(ctx, getMealItemsByMealID, mealID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserMealItem
	for rows.Next() {
		var i UserMealItem
		if err := rows.Scan(
			&i.ItemID,
			&i.MealID,
			&i.FoodName,
			&i.FoodID,
			&i.Seller,
			&i.ServingSize,
			&i.ServingSizeGrams,
			&i.Quantity,
			&i.Calories,
			&i.CarbsGrams,
			&i.FiberGrams,
			&i.ProteinGrams,
			&i.FatGrams,
			&i.SugarGrams,
			&i.SodiumMg,
			&i.GlycemicIndex,
			&i.GlycemicLoad,
			&i.FoodCategory,
			&i.CreatedAt,
			&i.SaturatedFatGrams,
			&i.MonounsaturatedFatGrams,
			&i.PolyunsaturatedFatGrams,
			&i.CholesterolMg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealLogByID = `-- name: GetMealLogByID :one
SELECT meal_id, user_id, meal_timestamp, meal_type_id, description, total_calories, total_carbs_grams, total_protein_grams, total_fat_grams, total_fiber_grams, total_sugar_grams, tags, created_at, updated_at FROM user_meal_logs WHERE meal_id = $1 AND user_id = $2
`

type GetMealLogByIDParams struct {
	MealID pgtype.UUID `json:"meal_id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) GetMealLogByID(ctx context.Context, arg GetMealLogByIDParams) (UserMealLog, error) {
	row := q.db.QueryRow(ctx, getMealLogByID, arg.MealID, arg.UserID)
	var i UserMealLog
	err := row.Scan(
		&i.MealID,
		&i.UserID,
		&i.MealTimestamp,
		&i.MealTypeID,
		&i.Description,
		&i.TotalCalories,
		&i.TotalCarbsGrams,
		&i.TotalProteinGrams,
		&i.TotalFatGrams,
		&i.TotalFiberGrams,
		&i.TotalSugarGrams,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMealLogs = `-- name: GetMealLogs :many
SELECT 
    ml.meal_id, 
    ml.meal_timestamp, 
    ml.meal_type_id,
    mt.display_name as meal_type_name,
    ml.description,
    ml.total_calories,
    ml.total_carbs_grams,
    ml.total_protein_grams,
    ml.total_fat_grams,
    ml.total_fiber_grams,
    ml.total_sugar_grams,
    ml.tags,
    ml.created_at,
    ml.updated_at
FROM user_meal_logs ml
JOIN meal_types mt ON ml.meal_type_id = mt.meal_type_id
WHERE user_id = $1
  AND meal_timestamp >= COALESCE($2, '1900-01-01'::timestamptz)
  AND meal_timestamp <= COALESCE($3, NOW() + INTERVAL '1 day')
ORDER BY meal_timestamp DESC
`

type GetMealLogsParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetMealLogsRow struct {
	MealID            pgtype.UUID        `json:"meal_id"`
	MealTimestamp     pgtype.Timestamptz `json:"meal_timestamp"`
	MealTypeID        int32              `json:"meal_type_id"`
	MealTypeName      string             `json:"meal_type_name"`
	Description       pgtype.Text        `json:"description"`
	TotalCalories     pgtype.Int4        `json:"total_calories"`
	TotalCarbsGrams   pgtype.Numeric     `json:"total_carbs_grams"`
	TotalProteinGrams pgtype.Numeric     `json:"total_protein_grams"`
	TotalFatGrams     pgtype.Numeric     `json:"total_fat_grams"`
	TotalFiberGrams   pgtype.Numeric     `json:"total_fiber_grams"`
	TotalSugarGrams   pgtype.Numeric     `json:"total_sugar_grams"`
	Tags              []string           `json:"tags"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves all meal logs for the user, ordered newest first, with optional date range
func (q *Queries) GetMealLogs(ctx context.Context, arg GetMealLogsParams) ([]GetMealLogsRow, error) {
	rows, err := q.db.Query(ctx, getMealLogs, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMealLogsRow
	for rows.Next() {
		var i GetMealLogsRow
		if err := rows.Scan(
			&i.MealID,
			&i.MealTimestamp,
			&i.MealTypeID,
			&i.MealTypeName,
			&i.Description,
			&i.TotalCalories,
			&i.TotalCarbsGrams,
			&i.TotalProteinGrams,
			&i.TotalFatGrams,
			&i.TotalFiberGrams,
			&i.TotalSugarGrams,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationLogs = `-- name: GetMedicationLogs :many
SELECT medicationlog_id, user_id, medication_id, medication_name, timestamp, dose_amount, reason, is_pump_delivery, delivery_duration_minutes, notes, created_at, updated_at FROM user_medication_logs
WHERE user_id = $1
  AND "timestamp" >= COALESCE($2, '1900-01-01'::timestamptz)
  AND "timestamp" <= COALESCE($3, NOW() + INTERVAL '1 day')
ORDER BY "timestamp" DESC
`

type GetMedicationLogsParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Retrieves logs for the user, with date filtering.
func (q *Queries) GetMedicationLogs(ctx context.Context, arg GetMedicationLogsParams) ([]UserMedicationLog, error) {
	rows, err := q.db.Query(ctx, getMedicationLogs, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserMedicationLog
	for rows.Next() {
		var i UserMedicationLog
		if err := rows.Scan(
			&i.MedicationlogID,
			&i.UserID,
			&i.MedicationID,
			&i.MedicationName,
			&i.Timestamp,
			&i.DoseAmount,
			&i.Reason,
			&i.IsPumpDelivery,
			&i.DeliveryDurationMinutes,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOTPCodeByEntityID = `-- name: GetOTPCodeByEntityID :one
SELECT otp_id, entity_id, entity_role, otp_secret, otp_purpose, otp_attempts, expires_at, created_at, deletion_scheduled_at FROM otp_codes
WHERE entity_id = $1
ORDER BY created_at DESC
LIMIT 1
`

// Don't check expires_at here, we'll handle expiry in code
func (q *Queries) GetOTPCodeByEntityID(ctx context.Context, entityID pgtype.UUID) (OtpCode, error) {
	row := q.db.QueryRow(ctx, getOTPCodeByEntityID, entityID)
	var i OtpCode
	err := row.Scan(
		&i.OtpID,
		&i.EntityID,
		&i.EntityRole,
		&i.OtpSecret,
		&i.OtpPurpose,
		&i.OtpAttempts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletionScheduledAt,
	)
	return i, err
}

const getOTPCodeWithCooldown = `-- name: GetOTPCodeWithCooldown :one
SELECT otp_id, entity_id, entity_role, otp_secret, otp_purpose, otp_attempts, expires_at, created_at, deletion_scheduled_at FROM otp_codes
WHERE entity_id = $1
AND created_at > NOW() - INTERVAL '1 minute'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetOTPCodeWithCooldown(ctx context.Context, entityID pgtype.UUID) (OtpCode, error) {
	row := q.db.QueryRow(ctx, getOTPCodeWithCooldown, entityID)
	var i OtpCode
	err := row.Scan(
		&i.OtpID,
		&i.EntityID,
		&i.EntityRole,
		&i.OtpSecret,
		&i.OtpPurpose,
		&i.OtpAttempts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.DeletionScheduledAt,
	)
	return i, err
}

const getOrderDetails = `-- name: GetOrderDetails :one
SELECT order_id, user_id, seller_id, total_price, status, delivery_address_json, payment_status, payment_method, created_at FROM user_orders
WHERE order_id = $1 AND user_id = $2
`

type GetOrderDetailsParams struct {
	OrderID pgtype.UUID `json:"order_id"`
	UserID  string      `json:"user_id"`
}

// Secure: checks that the order_id also belongs to the user_id
func (q *Queries) GetOrderDetails(ctx context.Context, arg GetOrderDetailsParams) (UserOrder, error) {
	row := q.db.QueryRow(ctx, getOrderDetails, arg.OrderID, arg.UserID)
	var i UserOrder
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.SellerID,
		&i.TotalPrice,
		&i.Status,
		&i.DeliveryAddressJson,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT order_item_id, order_id, food_id, quantity, price_at_purchase, food_name_snapshot FROM user_order_items
WHERE order_id = $1
`

func (q *Queries) GetOrderItems(ctx context.Context, orderID pgtype.UUID) ([]UserOrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOrderItem
	for rows.Next() {
		var i UserOrderItem
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.FoodID,
			&i.Quantity,
			&i.PriceAtPurchase,
			&i.FoodNameSnapshot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingRegistrationByEmail = `-- name: GetPendingRegistrationByEmail :one

SELECT pending_id, entity_role, email, username, hashed_password, first_name, last_name, raw_data, expires_at, created_at FROM pending_registrations
WHERE email = $1 AND expires_at > NOW()
`

// Return the new pending_id
func (q *Queries) GetPendingRegistrationByEmail(ctx context.Context, email string) (PendingRegistration, error) {
	row := q.db.QueryRow(ctx, getPendingRegistrationByEmail, email)
	var i PendingRegistration
	err := row.Scan(
		&i.PendingID,
		&i.EntityRole,
		&i.Email,
		&i.Username,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.RawData,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingRegistrationByID = `-- name: GetPendingRegistrationByID :one
SELECT pending_id, entity_role, email, username, hashed_password, first_name, last_name, raw_data, expires_at, created_at FROM pending_registrations
WHERE pending_id = $1 AND expires_at > NOW()
`

func (q *Queries) GetPendingRegistrationByID(ctx context.Context, pendingID pgtype.UUID) (PendingRegistration, error) {
	row := q.db.QueryRow(ctx, getPendingRegistrationByID, pendingID)
	var i PendingRegistration
	err := row.Scan(
		&i.PendingID,
		&i.EntityRole,
		&i.Email,
		&i.Username,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.RawData,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingRegistrationByUsername = `-- name: GetPendingRegistrationByUsername :one
SELECT pending_id, entity_role, email, username, hashed_password, first_name, last_name, raw_data, expires_at, created_at FROM pending_registrations
WHERE username = $1 AND expires_at > NOW()
`

func (q *Queries) GetPendingRegistrationByUsername(ctx context.Context, username pgtype.Text) (PendingRegistration, error) {
	row := q.db.QueryRow(ctx, getPendingRegistrationByUsername, username)
	var i PendingRegistration
	err := row.Scan(
		&i.PendingID,
		&i.EntityRole,
		&i.Email,
		&i.Username,
		&i.HashedPassword,
		&i.FirstName,
		&i.LastName,
		&i.RawData,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentAuthActivity = `-- name: GetRecentAuthActivity :many
SELECT log_id, user_id, log_category, log_action, log_message, log_level, ip_address, user_agent, metadata, created_at FROM logs_auth
WHERE user_id = $1
  AND created_at > $2
ORDER BY created_at DESC
LIMIT $3
`

type GetRecentAuthActivityParams struct {
	UserID    pgtype.Text        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) GetRecentAuthActivity(ctx context.Context, arg GetRecentAuthActivityParams) ([]LogsAuth, error) {
	rows, err := q.db.Query(ctx, getRecentAuthActivity, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogsAuth
	for rows.Next() {
		var i LogsAuth
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.LogCategory,
			&i.LogAction,
			&i.LogMessage,
			&i.LogLevel,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSessionsByCondition = `-- name: GetRecentSessionsByCondition :many
SELECT 
    rs.session_id,
    rs.user_id,
    rs.user_condition_id,
    rs.meal_type,
    rs.food_category_codes,
    rs.created_at,
    COUNT(DISTINCT rf.food_id) as foods_count,
    COUNT(DISTINCT rf.food_id) FILTER (WHERE rf.was_purchased = true) as foods_purchased,
    AVG(rf.user_rating) FILTER (WHERE rf.user_rating IS NOT NULL) as avg_food_rating
FROM recommendation_sessions rs
LEFT JOIN recommended_foods rf ON rs.session_id = rf.session_id
WHERE rs.user_condition_id = $1::INTEGER
    AND rs.created_at >= NOW() - INTERVAL '30 days'
    AND rs.expires_at > NOW()
GROUP BY rs.session_id
ORDER BY rs.created_at DESC
LIMIT 50
`

type GetRecentSessionsByConditionRow struct {
	SessionID         pgtype.UUID        `json:"session_id"`
	UserID            string             `json:"user_id"`
	UserConditionID   pgtype.Int4        `json:"user_condition_id"`
	MealType          pgtype.Text        `json:"meal_type"`
	FoodCategoryCodes []string           `json:"food_category_codes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	FoodsCount        int64              `json:"foods_count"`
	FoodsPurchased    int64              `json:"foods_purchased"`
	AvgFoodRating     float64            `json:"avg_food_rating"`
}

// Get recent sessions for users with similar health conditions
// Useful for analytics and learning patterns
func (q *Queries) GetRecentSessionsByCondition(ctx context.Context, conditionID int32) ([]GetRecentSessionsByConditionRow, error) {
	rows, err := q.db.Query(ctx, getRecentSessionsByCondition, conditionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentSessionsByConditionRow
	for rows.Next() {
		var i GetRecentSessionsByConditionRow
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.UserConditionID,
			&i.MealType,
			&i.FoodCategoryCodes,
			&i.CreatedAt,
			&i.FoodsCount,
			&i.FoodsPurchased,
			&i.AvgFoodRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecommendationEffectiveness = `-- name: GetRecommendationEffectiveness :many
SELECT user_id, user_condition_id, meal_type, recommendation_date, foods_recommended, foods_viewed, foods_purchased, avg_food_rating, activities_recommended, activities_viewed, activities_completed, avg_activity_rating, overall_feedback FROM recommendation_effectiveness
WHERE user_id = $1
    AND recommendation_date >= $2::DATE
ORDER BY recommendation_date DESC
`

type GetRecommendationEffectivenessParams struct {
	UserID    string      `json:"user_id"`
	StartDate pgtype.Date `json:"start_date"`
}

func (q *Queries) GetRecommendationEffectiveness(ctx context.Context, arg GetRecommendationEffectivenessParams) ([]RecommendationEffectiveness, error) {
	rows, err := q.db.Query(ctx, getRecommendationEffectiveness, arg.UserID, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecommendationEffectiveness
	for rows.Next() {
		var i RecommendationEffectiveness
		if err := rows.Scan(
			&i.UserID,
			&i.UserConditionID,
			&i.MealType,
			&i.RecommendationDate,
			&i.FoodsRecommended,
			&i.FoodsViewed,
			&i.FoodsPurchased,
			&i.AvgFoodRating,
			&i.ActivitiesRecommended,
			&i.ActivitiesViewed,
			&i.ActivitiesCompleted,
			&i.AvgActivityRating,
			&i.OverallFeedback,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecommendationSession = `-- name: GetRecommendationSession :one
SELECT session_id, user_id, requested_types, meal_type, food_category_codes, food_preferences, activity_type_codes, activity_preferences, insights_question, analysis_summary, insights_response, latest_glucose_value, latest_hba1c, user_condition_id, ai_model_used, ai_confidence_score, overall_feedback, feedback_notes, created_at, expires_at FROM recommendation_sessions
WHERE session_id = $1
`

func (q *Queries) GetRecommendationSession(ctx context.Context, sessionID pgtype.UUID) (RecommendationSession, error) {
	row := q.db.QueryRow(ctx, getRecommendationSession, sessionID)
	var i RecommendationSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.RequestedTypes,
		&i.MealType,
		&i.FoodCategoryCodes,
		&i.FoodPreferences,
		&i.ActivityTypeCodes,
		&i.ActivityPreferences,
		&i.InsightsQuestion,
		&i.AnalysisSummary,
		&i.InsightsResponse,
		&i.LatestGlucoseValue,
		&i.LatestHba1c,
		&i.UserConditionID,
		&i.AiModelUsed,
		&i.AiConfidenceScore,
		&i.OverallFeedback,
		&i.FeedbackNotes,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getRecommendationSessions = `-- name: GetRecommendationSessions :many

SELECT 
    session_id,
    user_id,
    requested_types,
    meal_type,
    food_category_codes,
    food_preferences,
    activity_type_codes,
    activity_preferences,
    insights_question,
    analysis_summary,
    insights_response,
    latest_glucose_value,
    latest_hba1c,
    user_condition_id,
    ai_model_used,
    ai_confidence_score,
    overall_feedback,
    feedback_notes,
    created_at,
    expires_at
FROM recommendation_sessions
WHERE user_id = $1
    AND (
        $2::BOOLEAN = true 
        OR expires_at > NOW()
    )
ORDER BY created_at DESC
LIMIT $4::INTEGER
OFFSET $3::INTEGER
`

type GetRecommendationSessionsParams struct {
	UserID         string `json:"user_id"`
	IncludeExpired bool   `json:"include_expired"`
	OffsetCount    int32  `json:"offset_count"`
	LimitCount     int32  `json:"limit_count"`
}

// =================================================================================
// RECOMMENDATION SESSION HISTORY QUERIES
// =================================================================================
func (q *Queries) GetRecommendationSessions(ctx context.Context, arg GetRecommendationSessionsParams) ([]RecommendationSession, error) {
	rows, err := q.db.Query(ctx, getRecommendationSessions,
		arg.UserID,
		arg.IncludeExpired,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecommendationSession
	for rows.Next() {
		var i RecommendationSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.RequestedTypes,
			&i.MealType,
			&i.FoodCategoryCodes,
			&i.FoodPreferences,
			&i.ActivityTypeCodes,
			&i.ActivityPreferences,
			&i.InsightsQuestion,
			&i.AnalysisSummary,
			&i.InsightsResponse,
			&i.LatestGlucoseValue,
			&i.LatestHba1c,
			&i.UserConditionID,
			&i.AiModelUsed,
			&i.AiConfidenceScore,
			&i.OverallFeedback,
			&i.FeedbackNotes,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecommendationSessionsCount = `-- name: GetRecommendationSessionsCount :one
SELECT COUNT(*)
FROM recommendation_sessions
WHERE user_id = $1
    AND (
        $2::BOOLEAN = true 
        OR expires_at > NOW()
    )
`

type GetRecommendationSessionsCountParams struct {
	UserID         string `json:"user_id"`
	IncludeExpired bool   `json:"include_expired"`
}

func (q *Queries) GetRecommendationSessionsCount(ctx context.Context, arg GetRecommendationSessionsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getRecommendationSessionsCount, arg.UserID, arg.IncludeExpired)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecommendedActivitiesInSession = `-- name: GetRecommendedActivitiesInSession :many
SELECT 
    ra.recommendation_activity_id, ra.session_id, ra.activity_id, ra.reason, ra.recommended_duration_minutes, ra.recommended_intensity, ra.safety_notes, ra.best_time_of_day, ra.glucose_management_tip, ra.recommendation_rank, ra.confidence_score, ra.was_viewed, ra.was_completed, ra.actual_duration_minutes, ra.user_rating, ra.feedback, ra.feedback_notes, ra.glucose_change_after_activity, ra.created_at, ra.completed_at, ra.last_interaction_at,
    a.activity_code,
    a.activity_name,
    a.description,
    a.image_url,
    a.met_value,
    a.measurement_unit
FROM recommended_activities ra
JOIN activities a ON ra.activity_id = a.id
WHERE ra.session_id = $1
ORDER BY ra.recommendation_rank ASC
`

type GetRecommendedActivitiesInSessionRow struct {
	RecommendationActivityID   pgtype.UUID        `json:"recommendation_activity_id"`
	SessionID                  pgtype.UUID        `json:"session_id"`
	ActivityID                 int32              `json:"activity_id"`
	Reason                     string             `json:"reason"`
	RecommendedDurationMinutes int32              `json:"recommended_duration_minutes"`
	RecommendedIntensity       pgtype.Text        `json:"recommended_intensity"`
	SafetyNotes                pgtype.Text        `json:"safety_notes"`
	BestTimeOfDay              pgtype.Text        `json:"best_time_of_day"`
	GlucoseManagementTip       pgtype.Text        `json:"glucose_management_tip"`
	RecommendationRank         pgtype.Int4        `json:"recommendation_rank"`
	ConfidenceScore            pgtype.Numeric     `json:"confidence_score"`
	WasViewed                  pgtype.Bool        `json:"was_viewed"`
	WasCompleted               pgtype.Bool        `json:"was_completed"`
	ActualDurationMinutes      pgtype.Int4        `json:"actual_duration_minutes"`
	UserRating                 pgtype.Int4        `json:"user_rating"`
	Feedback                   pgtype.Text        `json:"feedback"`
	FeedbackNotes              pgtype.Text        `json:"feedback_notes"`
	GlucoseChangeAfterActivity pgtype.Int4        `json:"glucose_change_after_activity"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	CompletedAt                pgtype.Timestamptz `json:"completed_at"`
	LastInteractionAt          pgtype.Timestamptz `json:"last_interaction_at"`
	ActivityCode               pgtype.Text        `json:"activity_code"`
	ActivityName               string             `json:"activity_name"`
	Description                pgtype.Text        `json:"description"`
	ImageUrl                   pgtype.Text        `json:"image_url"`
	MetValue                   pgtype.Numeric     `json:"met_value"`
	MeasurementUnit            pgtype.Text        `json:"measurement_unit"`
}

func (q *Queries) GetRecommendedActivitiesInSession(ctx context.Context, sessionID pgtype.UUID) ([]GetRecommendedActivitiesInSessionRow, error) {
	rows, err := q.db.Query(ctx, getRecommendedActivitiesInSession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecommendedActivitiesInSessionRow
	for rows.Next() {
		var i GetRecommendedActivitiesInSessionRow
		if err := rows.Scan(
			&i.RecommendationActivityID,
			&i.SessionID,
			&i.ActivityID,
			&i.Reason,
			&i.RecommendedDurationMinutes,
			&i.RecommendedIntensity,
			&i.SafetyNotes,
			&i.BestTimeOfDay,
			&i.GlucoseManagementTip,
			&i.RecommendationRank,
			&i.ConfidenceScore,
			&i.WasViewed,
			&i.WasCompleted,
			&i.ActualDurationMinutes,
			&i.UserRating,
			&i.Feedback,
			&i.FeedbackNotes,
			&i.GlucoseChangeAfterActivity,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.LastInteractionAt,
			&i.ActivityCode,
			&i.ActivityName,
			&i.Description,
			&i.ImageUrl,
			&i.MetValue,
			&i.MeasurementUnit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecommendedFoodsInSession = `-- name: GetRecommendedFoodsInSession :many
SELECT 
    rf.recommendation_food_id, rf.session_id, rf.food_id, rf.reason, rf.nutrition_highlight, rf.suggested_meal_type, rf.suggested_portion_size, rf.recommendation_rank, rf.confidence_score, rf.was_viewed, rf.was_added_to_cart, rf.was_purchased, rf.was_logged_as_meal, rf.user_rating, rf.feedback, rf.feedback_notes, rf.glucose_spike_after_eating, rf.created_at, rf.last_interaction_at,
    f.food_name,
    f.seller_id,
    f.description,
    f.price,
    f.currency,
    f.photo_url,
    f.thumbnail_url,
    f.is_available,
    f.tags,
    f.serving_size,
    f.calories,
    f.carbs_grams,
    f.fiber_grams,
    f.protein_grams,
    f.fat_grams,
    f.sugar_grams,
    f.sodium_mg,
    f.glycemic_index,
    f.glycemic_load
FROM recommended_foods rf
JOIN foods f ON rf.food_id = f.food_id
WHERE rf.session_id = $1
ORDER BY rf.recommendation_rank ASC
`

type GetRecommendedFoodsInSessionRow struct {
	RecommendationFoodID    pgtype.UUID        `json:"recommendation_food_id"`
	SessionID               pgtype.UUID        `json:"session_id"`
	FoodID                  pgtype.UUID        `json:"food_id"`
	Reason                  string             `json:"reason"`
	NutritionHighlight      pgtype.Text        `json:"nutrition_highlight"`
	SuggestedMealType       pgtype.Text        `json:"suggested_meal_type"`
	SuggestedPortionSize    pgtype.Text        `json:"suggested_portion_size"`
	RecommendationRank      pgtype.Int4        `json:"recommendation_rank"`
	ConfidenceScore         pgtype.Numeric     `json:"confidence_score"`
	WasViewed               pgtype.Bool        `json:"was_viewed"`
	WasAddedToCart          pgtype.Bool        `json:"was_added_to_cart"`
	WasPurchased            pgtype.Bool        `json:"was_purchased"`
	WasLoggedAsMeal         pgtype.Bool        `json:"was_logged_as_meal"`
	UserRating              pgtype.Int4        `json:"user_rating"`
	Feedback                pgtype.Text        `json:"feedback"`
	FeedbackNotes           pgtype.Text        `json:"feedback_notes"`
	GlucoseSpikeAfterEating pgtype.Int4        `json:"glucose_spike_after_eating"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	LastInteractionAt       pgtype.Timestamptz `json:"last_interaction_at"`
	FoodName                string             `json:"food_name"`
	SellerID                pgtype.UUID        `json:"seller_id"`
	Description             pgtype.Text        `json:"description"`
	Price                   pgtype.Numeric     `json:"price"`
	Currency                string             `json:"currency"`
	PhotoUrl                pgtype.Text        `json:"photo_url"`
	ThumbnailUrl            pgtype.Text        `json:"thumbnail_url"`
	IsAvailable             pgtype.Bool        `json:"is_available"`
	Tags                    []string           `json:"tags"`
	ServingSize             pgtype.Text        `json:"serving_size"`
	Calories                pgtype.Int4        `json:"calories"`
	CarbsGrams              pgtype.Numeric     `json:"carbs_grams"`
	FiberGrams              pgtype.Numeric     `json:"fiber_grams"`
	ProteinGrams            pgtype.Numeric     `json:"protein_grams"`
	FatGrams                pgtype.Numeric     `json:"fat_grams"`
	SugarGrams              pgtype.Numeric     `json:"sugar_grams"`
	SodiumMg                pgtype.Numeric     `json:"sodium_mg"`
	GlycemicIndex           pgtype.Int4        `json:"glycemic_index"`
	GlycemicLoad            pgtype.Numeric     `json:"glycemic_load"`
}

func (q *Queries) GetRecommendedFoodsInSession(ctx context.Context, sessionID pgtype.UUID) ([]GetRecommendedFoodsInSessionRow, error) {
	rows, err := q.db.Query(ctx, getRecommendedFoodsInSession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecommendedFoodsInSessionRow
	for rows.Next() {
		var i GetRecommendedFoodsInSessionRow
		if err := rows.Scan(
			&i.RecommendationFoodID,
			&i.SessionID,
			&i.FoodID,
			&i.Reason,
			&i.NutritionHighlight,
			&i.SuggestedMealType,
			&i.SuggestedPortionSize,
			&i.RecommendationRank,
			&i.ConfidenceScore,
			&i.WasViewed,
			&i.WasAddedToCart,
			&i.WasPurchased,
			&i.WasLoggedAsMeal,
			&i.UserRating,
			&i.Feedback,
			&i.FeedbackNotes,
			&i.GlucoseSpikeAfterEating,
			&i.CreatedAt,
			&i.LastInteractionAt,
			&i.FoodName,
			&i.SellerID,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.PhotoUrl,
			&i.ThumbnailUrl,
			&i.IsAvailable,
			&i.Tags,
			&i.ServingSize,
			&i.Calories,
			&i.CarbsGrams,
			&i.FiberGrams,
			&i.ProteinGrams,
			&i.FatGrams,
			&i.SugarGrams,
			&i.SodiumMg,
			&i.GlycemicIndex,
			&i.GlycemicLoad,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRefreshTokenByHash = `-- name: GetRefreshTokenByHash :one
SELECT id, user_id, token_hash, device_info, ip_address, expires_at, created_at, revoked_at, replaced_by_token_id FROM users_refresh_tokens
WHERE token_hash = $1 AND revoked_at IS NULL
`

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (UsersRefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByHash, tokenHash)
	var i UsersRefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.ReplacedByTokenID,
	)
	return i, err
}

const getSellerProfile = `-- name: GetSellerProfile :one
SELECT seller_id, user_id, created_at, updated_at, store_name, store_description, store_phone_number, is_open_manually, business_hours, verification_status, logo_url, banner_url, address_line1, address_line2, district, city, province, postal_code, latitude, longitude, gmaps_link FROM seller_profiles
WHERE seller_id = $1
`

func (q *Queries) GetSellerProfile(ctx context.Context, sellerID pgtype.UUID) (SellerProfile, error) {
	row := q.db.QueryRow(ctx, getSellerProfile, sellerID)
	var i SellerProfile
	err := row.Scan(
		&i.SellerID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StoreName,
		&i.StoreDescription,
		&i.StorePhoneNumber,
		&i.IsOpenManually,
		&i.BusinessHours,
		&i.VerificationStatus,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.District,
		&i.City,
		&i.Province,
		&i.PostalCode,
		&i.Latitude,
		&i.Longitude,
		&i.GmapsLink,
	)
	return i, err
}

const getSessionActivityMetrics = `-- name: GetSessionActivityMetrics :one
SELECT 
    COUNT(*) as activities_count,
    COUNT(*) FILTER (WHERE was_completed = true) as activities_completed,
    AVG(user_rating) FILTER (WHERE user_rating IS NOT NULL) as avg_rating,
    AVG(glucose_change_after_activity) FILTER (WHERE glucose_change_after_activity IS NOT NULL) as avg_glucose_change
FROM recommended_activities
WHERE session_id = $1
`

type GetSessionActivityMetricsRow struct {
	ActivitiesCount     int64   `json:"activities_count"`
	ActivitiesCompleted int64   `json:"activities_completed"`
	AvgRating           float64 `json:"avg_rating"`
	AvgGlucoseChange    float64 `json:"avg_glucose_change"`
}

func (q *Queries) GetSessionActivityMetrics(ctx context.Context, sessionID pgtype.UUID) (GetSessionActivityMetricsRow, error) {
	row := q.db.QueryRow(ctx, getSessionActivityMetrics, sessionID)
	var i GetSessionActivityMetricsRow
	err := row.Scan(
		&i.ActivitiesCount,
		&i.ActivitiesCompleted,
		&i.AvgRating,
		&i.AvgGlucoseChange,
	)
	return i, err
}

const getSessionEffectivenessStats = `-- name: GetSessionEffectivenessStats :one
SELECT 
    COUNT(DISTINCT rs.session_id) as total_sessions,
    COUNT(DISTINCT rf.food_id) as total_food_recommendations,
    COUNT(DISTINCT rf.food_id) FILTER (WHERE rf.was_purchased = true) as foods_purchased,
    COUNT(DISTINCT ra.activity_id) as total_activity_recommendations,
    COUNT(DISTINCT ra.activity_id) FILTER (WHERE ra.was_completed = true) as activities_completed,
    AVG(rf.user_rating) FILTER (WHERE rf.user_rating IS NOT NULL) as avg_food_rating,
    AVG(ra.user_rating) FILTER (WHERE ra.user_rating IS NOT NULL) as avg_activity_rating,
    AVG(rf.glucose_spike_after_eating) FILTER (WHERE rf.glucose_spike_after_eating IS NOT NULL) as avg_glucose_spike
FROM recommendation_sessions rs
LEFT JOIN recommended_foods rf ON rs.session_id = rf.session_id
LEFT JOIN recommended_activities ra ON rs.session_id = ra.session_id
WHERE rs.user_id = $1
    AND rs.created_at >= NOW() - INTERVAL '90 days'
`

type GetSessionEffectivenessStatsRow struct {
	TotalSessions                int64   `json:"total_sessions"`
	TotalFoodRecommendations     int64   `json:"total_food_recommendations"`
	FoodsPurchased               int64   `json:"foods_purchased"`
	TotalActivityRecommendations int64   `json:"total_activity_recommendations"`
	ActivitiesCompleted          int64   `json:"activities_completed"`
	AvgFoodRating                float64 `json:"avg_food_rating"`
	AvgActivityRating            float64 `json:"avg_activity_rating"`
	AvgGlucoseSpike              float64 `json:"avg_glucose_spike"`
}

// Get overall effectiveness statistics for a user
func (q *Queries) GetSessionEffectivenessStats(ctx context.Context, userID string) (GetSessionEffectivenessStatsRow, error) {
	row := q.db.QueryRow(ctx, getSessionEffectivenessStats, userID)
	var i GetSessionEffectivenessStatsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.TotalFoodRecommendations,
		&i.FoodsPurchased,
		&i.TotalActivityRecommendations,
		&i.ActivitiesCompleted,
		&i.AvgFoodRating,
		&i.AvgActivityRating,
		&i.AvgGlucoseSpike,
	)
	return i, err
}

const getSessionFoodMetrics = `-- name: GetSessionFoodMetrics :one
SELECT 
    COUNT(*) as foods_count,
    COUNT(*) FILTER (WHERE was_purchased = true) as foods_purchased,
    COUNT(*) FILTER (WHERE was_added_to_cart = true) as foods_added_to_cart,
    AVG(user_rating) FILTER (WHERE user_rating IS NOT NULL) as avg_rating,
    AVG(glucose_spike_after_eating) FILTER (WHERE glucose_spike_after_eating IS NOT NULL) as avg_glucose_spike
FROM recommended_foods
WHERE session_id = $1
`

type GetSessionFoodMetricsRow struct {
	FoodsCount       int64   `json:"foods_count"`
	FoodsPurchased   int64   `json:"foods_purchased"`
	FoodsAddedToCart int64   `json:"foods_added_to_cart"`
	AvgRating        float64 `json:"avg_rating"`
	AvgGlucoseSpike  float64 `json:"avg_glucose_spike"`
}

func (q *Queries) GetSessionFoodMetrics(ctx context.Context, sessionID pgtype.UUID) (GetSessionFoodMetricsRow, error) {
	row := q.db.QueryRow(ctx, getSessionFoodMetrics, sessionID)
	var i GetSessionFoodMetricsRow
	err := row.Scan(
		&i.FoodsCount,
		&i.FoodsPurchased,
		&i.FoodsAddedToCart,
		&i.AvgRating,
		&i.AvgGlucoseSpike,
	)
	return i, err
}

const getSessionsByDateRange = `-- name: GetSessionsByDateRange :many
SELECT 
    session_id,
    created_at,
    requested_types,
    meal_type,
    analysis_summary,
    overall_feedback
FROM recommendation_sessions
WHERE user_id = $1
    AND created_at >= $2::TIMESTAMPTZ
    AND created_at <= $3::TIMESTAMPTZ
ORDER BY created_at DESC
`

type GetSessionsByDateRangeParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

type GetSessionsByDateRangeRow struct {
	SessionID       pgtype.UUID        `json:"session_id"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	RequestedTypes  []string           `json:"requested_types"`
	MealType        pgtype.Text        `json:"meal_type"`
	AnalysisSummary string             `json:"analysis_summary"`
	OverallFeedback pgtype.Text        `json:"overall_feedback"`
}

// Get user's sessions within a date range
func (q *Queries) GetSessionsByDateRange(ctx context.Context, arg GetSessionsByDateRangeParams) ([]GetSessionsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getSessionsByDateRange, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionsByDateRangeRow
	for rows.Next() {
		var i GetSessionsByDateRangeRow
		if err := rows.Scan(
			&i.SessionID,
			&i.CreatedAt,
			&i.RequestedTypes,
			&i.MealType,
			&i.AnalysisSummary,
			&i.OverallFeedback,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepLogByID = `-- name: GetSleepLogByID :one
SELECT sleep_id, user_id, sleep_date, bed_time, wake_time, quality_rating, tracker_score, deep_sleep_minutes, rem_sleep_minutes, light_sleep_minutes, awake_minutes, average_hrv, resting_heart_rate, tags, source, notes, created_at, updated_at FROM user_sleep_logs
WHERE sleep_id = $1 AND user_id = $2
`

type GetSleepLogByIDParams struct {
	SleepID pgtype.UUID `json:"sleep_id"`
	UserID  string      `json:"user_id"`
}

// Retrieves a single sleep log, checking for user ownership
func (q *Queries) GetSleepLogByID(ctx context.Context, arg GetSleepLogByIDParams) (UserSleepLog, error) {
	row := q.db.QueryRow(ctx, getSleepLogByID, arg.SleepID, arg.UserID)
	var i UserSleepLog
	err := row.Scan(
		&i.SleepID,
		&i.UserID,
		&i.SleepDate,
		&i.BedTime,
		&i.WakeTime,
		&i.QualityRating,
		&i.TrackerScore,
		&i.DeepSleepMinutes,
		&i.RemSleepMinutes,
		&i.LightSleepMinutes,
		&i.AwakeMinutes,
		&i.AverageHrv,
		&i.RestingHeartRate,
		&i.Tags,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSleepLogs = `-- name: GetSleepLogs :many
SELECT sleep_id, user_id, sleep_date, bed_time, wake_time, quality_rating, tracker_score, deep_sleep_minutes, rem_sleep_minutes, light_sleep_minutes, awake_minutes, average_hrv, resting_heart_rate, tags, source, notes, created_at, updated_at FROM user_sleep_logs
WHERE user_id = $1
  AND bed_time >= COALESCE($2, '1900-01-01'::timestamptz)
  AND bed_time <= COALESCE($3, NOW() + INTERVAL '1 day')
ORDER BY sleep_date DESC
`

type GetSleepLogsParams struct {
	UserID    string             `json:"user_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

// Retrieves all sleep logs for the user, with date filtering
func (q *Queries) GetSleepLogs(ctx context.Context, arg GetSleepLogsParams) ([]UserSleepLog, error) {
	rows, err := q.db.Query(ctx, getSleepLogs, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSleepLog
	for rows.Next() {
		var i UserSleepLog
		if err := rows.Scan(
			&i.SleepID,
			&i.UserID,
			&i.SleepDate,
			&i.BedTime,
			&i.WakeTime,
			&i.QualityRating,
			&i.TrackerScore,
			&i.DeepSleepMinutes,
			&i.RemSleepMinutes,
			&i.LightSleepMinutes,
			&i.AwakeMinutes,
			&i.AverageHrv,
			&i.RestingHeartRate,
			&i.Tags,
			&i.Source,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedActivities = `-- name: GetTopRatedActivities :many
SELECT 
    a.id,
    a.activity_name,
    a.image_url,
    COUNT(ra.recommendation_activity_id) as times_recommended,
    AVG(ra.user_rating) as avg_rating,
    COUNT(ra.recommendation_activity_id) FILTER (WHERE ra.was_completed = true) as completion_count
FROM activities a
JOIN recommended_activities ra ON a.id = ra.activity_id
JOIN recommendation_sessions rs ON ra.session_id = rs.session_id
WHERE rs.user_id = $1
    AND ra.user_rating IS NOT NULL
GROUP BY a.id
HAVING COUNT(ra.user_rating) >= 3
ORDER BY AVG(ra.user_rating) DESC, COUNT(ra.was_completed) DESC
LIMIT 10
`

type GetTopRatedActivitiesRow struct {
	ID               int32       `json:"id"`
	ActivityName     string      `json:"activity_name"`
	ImageUrl         pgtype.Text `json:"image_url"`
	TimesRecommended int64       `json:"times_recommended"`
	AvgRating        float64     `json:"avg_rating"`
	CompletionCount  int64       `json:"completion_count"`
}

func (q *Queries) GetTopRatedActivities(ctx context.Context, userID string) ([]GetTopRatedActivitiesRow, error) {
	rows, err := q.db.Query(ctx, getTopRatedActivities, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopRatedActivitiesRow
	for rows.Next() {
		var i GetTopRatedActivitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ActivityName,
			&i.ImageUrl,
			&i.TimesRecommended,
			&i.AvgRating,
			&i.CompletionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRatedFoods = `-- name: GetTopRatedFoods :many
SELECT 
    f.food_id,
    f.food_name,
    f.photo_url,
    COUNT(rf.recommendation_food_id) as times_recommended,
    AVG(rf.user_rating) as avg_rating,
    COUNT(rf.recommendation_food_id) FILTER (WHERE rf.was_purchased = true) as purchase_count
FROM foods f
JOIN recommended_foods rf ON f.food_id = rf.food_id
JOIN recommendation_sessions rs ON rf.session_id = rs.session_id
WHERE rs.user_id = $1
    AND rf.user_rating IS NOT NULL
GROUP BY f.food_id
HAVING COUNT(rf.user_rating) >= 3
ORDER BY AVG(rf.user_rating) DESC, COUNT(rf.was_purchased) DESC
LIMIT 10
`

type GetTopRatedFoodsRow struct {
	FoodID           pgtype.UUID `json:"food_id"`
	FoodName         string      `json:"food_name"`
	PhotoUrl         pgtype.Text `json:"photo_url"`
	TimesRecommended int64       `json:"times_recommended"`
	AvgRating        float64     `json:"avg_rating"`
	PurchaseCount    int64       `json:"purchase_count"`
}

func (q *Queries) GetTopRatedFoods(ctx context.Context, userID string) ([]GetTopRatedFoodsRow, error) {
	rows, err := q.db.Query(ctx, getTopRatedFoods, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopRatedFoodsRow
	for rows.Next() {
		var i GetTopRatedFoodsRow
		if err := rows.Scan(
			&i.FoodID,
			&i.FoodName,
			&i.PhotoUrl,
			&i.TimesRecommended,
			&i.AvgRating,
			&i.PurchaseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveRefreshTokens = `-- name: GetUserActiveRefreshTokens :many
/* ====================================================================
                           Unused Queries
==================================================================== */
SELECT id, user_id, token_hash, device_info, ip_address, expires_at, created_at, revoked_at, replaced_by_token_id FROM users_refresh_tokens
WHERE user_id = $1 
  AND revoked_at IS NULL 
  AND expires_at > CURRENT_TIMESTAMP
ORDER BY created_at DESC
`

func (q *Queries) GetUserActiveRefreshTokens(ctx context.Context, userID string) ([]UsersRefreshToken, error) {
	rows, err := q.db.Query(ctx, getUserActiveRefreshTokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersRefreshToken
	for rows.Next() {
		var i UsersRefreshToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenHash,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.RevokedAt,
			&i.ReplacedByTokenID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAddressByID = `-- name: GetUserAddressByID :one
SELECT address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district FROM user_addresses
WHERE address_id = $1 AND user_id = $2 AND is_active = true
`

type GetUserAddressByIDParams struct {
	AddressID pgtype.UUID `json:"address_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) GetUserAddressByID(ctx context.Context, arg GetUserAddressByIDParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, getUserAddressByID, arg.AddressID, arg.UserID)
	var i UserAddress
	err := row.Scan(
		&i.AddressID,
		&i.UserID,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.AddressCity,
		&i.AddressProvince,
		&i.AddressPostalcode,
		&i.AddressLatitude,
		&i.AddressLongitude,
		&i.AddressLabel,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.DeliveryNotes,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressDistrict,
	)
	return i, err
}

const getUserAddresses = `-- name: GetUserAddresses :many
SELECT address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district FROM user_addresses
WHERE user_id = $1 AND is_active = true
ORDER BY is_default DESC, created_at DESC
`

func (q *Queries) GetUserAddresses(ctx context.Context, userID string) ([]UserAddress, error) {
	rows, err := q.db.Query(ctx, getUserAddresses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAddress
	for rows.Next() {
		var i UserAddress
		if err := rows.Scan(
			&i.AddressID,
			&i.UserID,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.AddressCity,
			&i.AddressProvince,
			&i.AddressPostalcode,
			&i.AddressLatitude,
			&i.AddressLongitude,
			&i.AddressLabel,
			&i.RecipientName,
			&i.RecipientPhone,
			&i.DeliveryNotes,
			&i.IsDefault,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressDistrict,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at FROM users
WHERE user_email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, userEmail pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, userEmail)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserByOAuthEmail = `-- name: GetUserByOAuthEmail :one
SELECT user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at FROM users
WHERE user_email_auth = $1 AND user_provider IS NOT NULL
`

func (q *Queries) GetUserByOAuthEmail(ctx context.Context, userEmailAuth pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByOAuthEmail, userEmailAuth)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at FROM users
WHERE user_username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, userUsername pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, userUsername)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserDemographics = `-- name: GetUserDemographics :one
SELECT 
    CAST(EXTRACT(YEAR FROM AGE(CURRENT_DATE, user_DOB)) AS INTEGER) as age,
    user_gender
FROM users
WHERE user_id = $1
`

type GetUserDemographicsRow struct {
	Age        int32               `json:"age"`
	UserGender NullUsersUserGender `json:"user_gender"`
}

func (q *Queries) GetUserDemographics(ctx context.Context, userID string) (GetUserDemographicsRow, error) {
	row := q.db.QueryRow(ctx, getUserDemographics, userID)
	var i GetUserDemographicsRow
	err := row.Scan(&i.Age, &i.UserGender)
	return i, err
}

const getUserHealthProfile = `-- name: GetUserHealthProfile :one
/* ====================================================================
                   Health Profile Queries
==================================================================== */

SELECT profile_id, user_id, app_experience, condition_id, diagnosis_date, years_with_condition, treatment_types, target_glucose_fasting, target_glucose_postprandial, uses_cgm, cgm_device, cgm_api_connected, height_cm, current_weight_kg, target_weight_kg, bmi, waist_circumference_cm, body_fat_percentage, hba1c_target, last_hba1c, last_hba1c_date, activity_level, daily_steps_goal, weekly_exercise_goal_minutes, preferred_activity_type_ids, dietary_pattern, daily_carb_target_grams, daily_calorie_target, daily_protein_target_grams, daily_fat_target_grams, meals_per_day, snacks_per_day, food_allergies, food_intolerances, foods_to_avoid, cultural_cuisines, dietary_restrictions, has_hypertension, hypertension_medication, has_kidney_disease, kidney_disease_stage, egfr_value, has_cardiovascular_disease, has_neuropathy, has_retinopathy, has_gastroparesis, has_hypoglycemia_unawareness, other_conditions, smoking_status, smoking_years, alcohol_frequency, alcohol_drinks_per_week, stress_level, typical_sleep_hours, sleep_quality, is_pregnant, is_breastfeeding, expected_due_date, preferred_units, glucose_unit, timezone, language_code, enable_glucose_alerts, enable_meal_reminders, enable_activity_reminders, enable_medication_reminders, share_data_for_research, share_anonymized_data, created_at, updated_at FROM user_health_profiles
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserHealthProfile(ctx context.Context, userID string) (UserHealthProfile, error) {
	row := q.db.QueryRow(ctx, getUserHealthProfile, userID)
	var i UserHealthProfile
	err := row.Scan(
		&i.ProfileID,
		&i.UserID,
		&i.AppExperience,
		&i.ConditionID,
		&i.DiagnosisDate,
		&i.YearsWithCondition,
		&i.TreatmentTypes,
		&i.TargetGlucoseFasting,
		&i.TargetGlucosePostprandial,
		&i.UsesCgm,
		&i.CgmDevice,
		&i.CgmApiConnected,
		&i.HeightCm,
		&i.CurrentWeightKg,
		&i.TargetWeightKg,
		&i.Bmi,
		&i.WaistCircumferenceCm,
		&i.BodyFatPercentage,
		&i.Hba1cTarget,
		&i.LastHba1c,
		&i.LastHba1cDate,
		&i.ActivityLevel,
		&i.DailyStepsGoal,
		&i.WeeklyExerciseGoalMinutes,
		&i.PreferredActivityTypeIds,
		&i.DietaryPattern,
		&i.DailyCarbTargetGrams,
		&i.DailyCalorieTarget,
		&i.DailyProteinTargetGrams,
		&i.DailyFatTargetGrams,
		&i.MealsPerDay,
		&i.SnacksPerDay,
		&i.FoodAllergies,
		&i.FoodIntolerances,
		&i.FoodsToAvoid,
		&i.CulturalCuisines,
		&i.DietaryRestrictions,
		&i.HasHypertension,
		&i.HypertensionMedication,
		&i.HasKidneyDisease,
		&i.KidneyDiseaseStage,
		&i.EgfrValue,
		&i.HasCardiovascularDisease,
		&i.HasNeuropathy,
		&i.HasRetinopathy,
		&i.HasGastroparesis,
		&i.HasHypoglycemiaUnawareness,
		&i.OtherConditions,
		&i.SmokingStatus,
		&i.SmokingYears,
		&i.AlcoholFrequency,
		&i.AlcoholDrinksPerWeek,
		&i.StressLevel,
		&i.TypicalSleepHours,
		&i.SleepQuality,
		&i.IsPregnant,
		&i.IsBreastfeeding,
		&i.ExpectedDueDate,
		&i.PreferredUnits,
		&i.GlucoseUnit,
		&i.Timezone,
		&i.LanguageCode,
		&i.EnableGlucoseAlerts,
		&i.EnableMealReminders,
		&i.EnableActivityReminders,
		&i.EnableMedicationReminders,
		&i.ShareDataForResearch,
		&i.ShareAnonymizedData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMedicationByID = `-- name: GetUserMedicationByID :one
SELECT medication_id, user_id, display_name, medication_type, default_dose_unit, is_active, created_at, updated_at FROM user_medications
WHERE medication_id = $1 AND user_id = $2
`

type GetUserMedicationByIDParams struct {
	MedicationID int32       `json:"medication_id"`
	UserID       pgtype.Text `json:"user_id"`
}

// Retrieves a single medication configuration, checking for user ownership.
func (q *Queries) GetUserMedicationByID(ctx context.Context, arg GetUserMedicationByIDParams) (UserMedication, error) {
	row := q.db.QueryRow(ctx, getUserMedicationByID, arg.MedicationID, arg.UserID)
	var i UserMedication
	err := row.Scan(
		&i.MedicationID,
		&i.UserID,
		&i.DisplayName,
		&i.MedicationType,
		&i.DefaultDoseUnit,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMedications = `-- name: GetUserMedications :many
SELECT medication_id, user_id, display_name, medication_type, default_dose_unit, is_active, created_at, updated_at FROM user_medications
WHERE user_id = $1 AND is_active = true
ORDER BY display_name
`

// Retrieves all active medications configured by the user.
func (q *Queries) GetUserMedications(ctx context.Context, userID pgtype.Text) ([]UserMedication, error) {
	rows, err := q.db.Query(ctx, getUserMedications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserMedication
	for rows.Next() {
		var i UserMedication
		if err := rows.Scan(
			&i.MedicationID,
			&i.UserID,
			&i.DisplayName,
			&i.MedicationType,
			&i.DefaultDoseUnit,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrders = `-- name: GetUserOrders :many
SELECT order_id, user_id, seller_id, total_price, status, delivery_address_json, payment_status, payment_method, created_at FROM user_orders
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserOrders(ctx context.Context, userID string) ([]UserOrder, error) {
	rows, err := q.db.Query(ctx, getUserOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserOrder
	for rows.Next() {
		var i UserOrder
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.SellerID,
			&i.TotalPrice,
			&i.Status,
			&i.DeliveryAddressJson,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProviderID = `-- name: GetUserProviderID :one
SELECT user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at FROM users
WHERE user_provider_user_id = $1 LIMIT 1
`

func (q *Queries) GetUserProviderID(ctx context.Context, userProviderUserID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserProviderID, userProviderUserID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const getUserRecommendationHistory = `-- name: GetUserRecommendationHistory :many
SELECT 
    rs.session_id,
    rs.created_at,
    rs.analysis_summary,
    rs.meal_type,
    rs.requested_types,
    rs.overall_feedback,
    COUNT(DISTINCT rf.food_id) as foods_count,
    COUNT(DISTINCT ra.activity_id) as activities_count
FROM recommendation_sessions rs
LEFT JOIN recommended_foods rf ON rs.session_id = rf.session_id
LEFT JOIN recommended_activities ra ON rs.session_id = ra.session_id
WHERE rs.user_id = $1
GROUP BY rs.session_id
ORDER BY rs.created_at DESC
LIMIT $2::INTEGER
`

type GetUserRecommendationHistoryParams struct {
	UserID     string `json:"user_id"`
	LimitCount int32  `json:"limit_count"`
}

type GetUserRecommendationHistoryRow struct {
	SessionID       pgtype.UUID        `json:"session_id"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	AnalysisSummary string             `json:"analysis_summary"`
	MealType        pgtype.Text        `json:"meal_type"`
	RequestedTypes  []string           `json:"requested_types"`
	OverallFeedback pgtype.Text        `json:"overall_feedback"`
	FoodsCount      int64              `json:"foods_count"`
	ActivitiesCount int64              `json:"activities_count"`
}

func (q *Queries) GetUserRecommendationHistory(ctx context.Context, arg GetUserRecommendationHistoryParams) ([]GetUserRecommendationHistoryRow, error) {
	rows, err := q.db.Query(ctx, getUserRecommendationHistory, arg.UserID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRecommendationHistoryRow
	for rows.Next() {
		var i GetUserRecommendationHistoryRow
		if err := rows.Scan(
			&i.SessionID,
			&i.CreatedAt,
			&i.AnalysisSummary,
			&i.MealType,
			&i.RequestedTypes,
			&i.OverallFeedback,
			&i.FoodsCount,
			&i.ActivitiesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteUserAddress = `-- name: HardDeleteUserAddress :exec
DELETE FROM user_addresses
WHERE address_id = $1 AND user_id = $2
`

type HardDeleteUserAddressParams struct {
	AddressID pgtype.UUID `json:"address_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) HardDeleteUserAddress(ctx context.Context, arg HardDeleteUserAddressParams) error {
	_, err := q.db.Exec(ctx, hardDeleteUserAddress, arg.AddressID, arg.UserID)
	return err
}

const ifAddressIsDefault = `-- name: IfAddressIsDefault :one
SELECT is_default FROM user_addresses
WHERE address_id = $1
`

func (q *Queries) IfAddressIsDefault(ctx context.Context, addressID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, ifAddressIsDefault, addressID)
	var is_default bool
	err := row.Scan(&is_default)
	return is_default, err
}

const listAllAvailableFoods = `-- name: ListAllAvailableFoods :many
SELECT food_id, seller_id, food_name, description, price, currency, photo_url, thumbnail_url, is_available, stock_count, tags, created_at, updated_at, serving_size, serving_size_grams, quantity, calories, carbs_grams, fiber_grams, protein_grams, fat_grams, sugar_grams, sodium_mg, glycemic_index, glycemic_load, food_category, saturated_fat_grams, monounsaturated_fat_grams, polyunsaturated_fat_grams, cholesterol_mg
FROM foods
WHERE is_available = true
ORDER BY food_name
`

// Retrieves a list of all food items currently marked as available
func (q *Queries) ListAllAvailableFoods(ctx context.Context) ([]Food, error) {
	rows, err := q.db.Query(ctx, listAllAvailableFoods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.SellerID,
			&i.FoodName,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.PhotoUrl,
			&i.ThumbnailUrl,
			&i.IsAvailable,
			&i.StockCount,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServingSize,
			&i.ServingSizeGrams,
			&i.Quantity,
			&i.Calories,
			&i.CarbsGrams,
			&i.FiberGrams,
			&i.ProteinGrams,
			&i.FatGrams,
			&i.SugarGrams,
			&i.SodiumMg,
			&i.GlycemicIndex,
			&i.GlycemicLoad,
			&i.FoodCategory,
			&i.SaturatedFatGrams,
			&i.MonounsaturatedFatGrams,
			&i.PolyunsaturatedFatGrams,
			&i.CholesterolMg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecommendedActivities = `-- name: ListRecommendedActivities :many
SELECT 
    a.id,
    a.activity_code,
    a.activity_name,
    a.description,
    a.image_url,
    a.met_value,
    a.measurement_unit,
    a.recommended_min_value
FROM activities a
WHERE (
    $1::TEXT[] IS NULL
    OR a.activity_code = ANY($1::TEXT[])
)
ORDER BY a.met_value ASC
LIMIT 20
`

func (q *Queries) ListRecommendedActivities(ctx context.Context, activityCodes []string) ([]Activity, error) {
	rows, err := q.db.Query(ctx, listRecommendedActivities, activityCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Activity
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.ActivityCode,
			&i.ActivityName,
			&i.Description,
			&i.ImageUrl,
			&i.MetValue,
			&i.MeasurementUnit,
			&i.RecommendedMinValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecommendedFoods = `-- name: ListRecommendedFoods :many
/*
Filters applied:

is_available = true  Only show foods in stock
food_category IN [...]  Only requested categories (e.g., "ASIAN_GENERIC")
glycemic_load <= max  Safety limit (e.g., GL < 10 for diabetics)
carbs_grams <= max  Carb limit (e.g., < 30g per meal)

Ordering:

Primary: Low glycemic load first (safer for blood sugar)
Secondary: High fiber (better for glucose control)
*/
SELECT food_id, seller_id, food_name, description, price, currency, photo_url, thumbnail_url, is_available, stock_count, tags, created_at, updated_at, serving_size, serving_size_grams, quantity, calories, carbs_grams, fiber_grams, protein_grams, fat_grams, sugar_grams, sodium_mg, glycemic_index, glycemic_load, food_category, saturated_fat_grams, monounsaturated_fat_grams, polyunsaturated_fat_grams, cholesterol_mg FROM foods
WHERE is_available = true
    AND (
        $1::TEXT[] IS NULL 
        OR food_category::TEXT[] && $1::TEXT[]
    )
    AND (
        $2::NUMERIC IS NULL 
        OR glycemic_load <= $2
    )
    AND (
        $3::NUMERIC IS NULL 
        OR carbs_grams <= $3
    )
ORDER BY 
    CASE 
        WHEN glycemic_load IS NOT NULL THEN glycemic_load
        ELSE 999
    END ASC,
    fiber_grams DESC,
    protein_grams DESC
LIMIT $4::INTEGER
`

type ListRecommendedFoodsParams struct {
	FoodCategory    []string       `json:"food_category"`
	MaxGlycemicLoad pgtype.Numeric `json:"max_glycemic_load"`
	MaxCarbs        pgtype.Numeric `json:"max_carbs"`
	LimitCount      int32          `json:"limit_count"`
}

// Fetches foods from database based on user's filters BEFORE sending to AI.
func (q *Queries) ListRecommendedFoods(ctx context.Context, arg ListRecommendedFoodsParams) ([]Food, error) {
	rows, err := q.db.Query(ctx, listRecommendedFoods,
		arg.FoodCategory,
		arg.MaxGlycemicLoad,
		arg.MaxCarbs,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Food
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.FoodID,
			&i.SellerID,
			&i.FoodName,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.PhotoUrl,
			&i.ThumbnailUrl,
			&i.IsAvailable,
			&i.StockCount,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServingSize,
			&i.ServingSizeGrams,
			&i.Quantity,
			&i.Calories,
			&i.CarbsGrams,
			&i.FiberGrams,
			&i.ProteinGrams,
			&i.FatGrams,
			&i.SugarGrams,
			&i.SodiumMg,
			&i.GlycemicIndex,
			&i.GlycemicLoad,
			&i.FoodCategory,
			&i.SaturatedFatGrams,
			&i.MonounsaturatedFatGrams,
			&i.PolyunsaturatedFatGrams,
			&i.CholesterolMg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markActivityCompleted = `-- name: MarkActivityCompleted :exec
UPDATE recommended_activities
SET was_completed = true,
    completed_at = NOW(),
    actual_duration_minutes = $3,
    last_interaction_at = NOW()
WHERE session_id = $1 AND activity_id = $2
`

type MarkActivityCompletedParams struct {
	SessionID             pgtype.UUID `json:"session_id"`
	ActivityID            int32       `json:"activity_id"`
	ActualDurationMinutes pgtype.Int4 `json:"actual_duration_minutes"`
}

func (q *Queries) MarkActivityCompleted(ctx context.Context, arg MarkActivityCompletedParams) error {
	_, err := q.db.Exec(ctx, markActivityCompleted, arg.SessionID, arg.ActivityID, arg.ActualDurationMinutes)
	return err
}

const markFoodAddedToCart = `-- name: MarkFoodAddedToCart :exec
UPDATE recommended_foods
SET was_added_to_cart = true,
    last_interaction_at = NOW()
WHERE session_id = $1 AND food_id = $2
`

type MarkFoodAddedToCartParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	FoodID    pgtype.UUID `json:"food_id"`
}

func (q *Queries) MarkFoodAddedToCart(ctx context.Context, arg MarkFoodAddedToCartParams) error {
	_, err := q.db.Exec(ctx, markFoodAddedToCart, arg.SessionID, arg.FoodID)
	return err
}

const markFoodPurchased = `-- name: MarkFoodPurchased :exec
UPDATE recommended_foods
SET was_purchased = true,
    last_interaction_at = NOW()
WHERE session_id = $1 AND food_id = $2
`

type MarkFoodPurchasedParams struct {
	SessionID pgtype.UUID `json:"session_id"`
	FoodID    pgtype.UUID `json:"food_id"`
}

func (q *Queries) MarkFoodPurchased(ctx context.Context, arg MarkFoodPurchasedParams) error {
	_, err := q.db.Exec(ctx, markFoodPurchased, arg.SessionID, arg.FoodID)
	return err
}

const revokeAllUserRefreshTokens = `-- name: RevokeAllUserRefreshTokens :exec
UPDATE users_refresh_tokens 
SET revoked_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllUserRefreshTokens(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, revokeAllUserRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE users_refresh_tokens 
SET revoked_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, id)
	return err
}

const searchRecommendationSessions = `-- name: SearchRecommendationSessions :many
SELECT 
    rs.session_id,
    rs.created_at,
    rs.requested_types,
    rs.meal_type,
    rs.food_category_codes,
    rs.analysis_summary,
    rs.overall_feedback
FROM recommendation_sessions rs
WHERE rs.user_id = $1
    AND (
        $2::TEXT IS NULL
        OR rs.analysis_summary ILIKE '%' || $2 || '%'
        OR $2 = ANY(rs.requested_types)
        OR $2 = ANY(rs.food_category_codes)
        OR rs.meal_type = $2
    )
    AND (
        $3::TEXT IS NULL
        OR rs.overall_feedback = $3
    )
ORDER BY rs.created_at DESC
LIMIT 50
`

type SearchRecommendationSessionsParams struct {
	UserID         string `json:"user_id"`
	SearchQuery    string `json:"search_query"`
	FeedbackFilter string `json:"feedback_filter"`
}

type SearchRecommendationSessionsRow struct {
	SessionID         pgtype.UUID        `json:"session_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	RequestedTypes    []string           `json:"requested_types"`
	MealType          pgtype.Text        `json:"meal_type"`
	FoodCategoryCodes []string           `json:"food_category_codes"`
	AnalysisSummary   string             `json:"analysis_summary"`
	OverallFeedback   pgtype.Text        `json:"overall_feedback"`
}

// Search sessions by various criteria
func (q *Queries) SearchRecommendationSessions(ctx context.Context, arg SearchRecommendationSessionsParams) ([]SearchRecommendationSessionsRow, error) {
	rows, err := q.db.Query(ctx, searchRecommendationSessions, arg.UserID, arg.SearchQuery, arg.FeedbackFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchRecommendationSessionsRow
	for rows.Next() {
		var i SearchRecommendationSessionsRow
		if err := rows.Scan(
			&i.SessionID,
			&i.CreatedAt,
			&i.RequestedTypes,
			&i.MealType,
			&i.FoodCategoryCodes,
			&i.AnalysisSummary,
			&i.OverallFeedback,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCartSeller = `-- name: SetCartSeller :exec
UPDATE user_carts
SET seller_id = $2
WHERE user_id = $1
`

type SetCartSellerParams struct {
	UserID   string      `json:"user_id"`
	SellerID pgtype.UUID `json:"seller_id"`
}

func (q *Queries) SetCartSeller(ctx context.Context, arg SetCartSellerParams) error {
	_, err := q.db.Exec(ctx, setCartSeller, arg.UserID, arg.SellerID)
	return err
}

const setDefaultAddress = `-- name: SetDefaultAddress :one
UPDATE user_addresses
SET is_default = true
WHERE address_id = $1 AND user_id = $2 AND is_active = true
RETURNING address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district
`

type SetDefaultAddressParams struct {
	AddressID pgtype.UUID `json:"address_id"`
	UserID    string      `json:"user_id"`
}

func (q *Queries) SetDefaultAddress(ctx context.Context, arg SetDefaultAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, setDefaultAddress, arg.AddressID, arg.UserID)
	var i UserAddress
	err := row.Scan(
		&i.AddressID,
		&i.UserID,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.AddressCity,
		&i.AddressProvince,
		&i.AddressPostalcode,
		&i.AddressLatitude,
		&i.AddressLongitude,
		&i.AddressLabel,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.DeliveryNotes,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressDistrict,
	)
	return i, err
}

const unlinkGoogleAccount = `-- name: UnlinkGoogleAccount :exec
UPDATE users
SET 
  user_name_auth = NULL,
  user_provider = NULL,
  user_provider_user_id = NULL,
  user_avatar_url = NULL,   -- Clear the avatar linked to Google
  user_raw_data = NULL     -- Clear the raw data from Google
WHERE 
  user_id = $1
`

func (q *Queries) UnlinkGoogleAccount(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, unlinkGoogleAccount, userID)
	return err
}

const unsetDefaultAddress = `-- name: UnsetDefaultAddress :exec
UPDATE user_addresses
SET is_default = false
WHERE user_id = $1 AND address_id != $2 AND is_default = true
`

type UnsetDefaultAddressParams struct {
	UserID    string      `json:"user_id"`
	AddressID pgtype.UUID `json:"address_id"`
}

func (q *Queries) UnsetDefaultAddress(ctx context.Context, arg UnsetDefaultAddressParams) error {
	_, err := q.db.Exec(ctx, unsetDefaultAddress, arg.UserID, arg.AddressID)
	return err
}

const updateActivityLog = `-- name: UpdateActivityLog :one
UPDATE user_activity_logs
SET
    activity_timestamp = COALESCE($3, activity_timestamp),
    activity_code = COALESCE($4, activity_code),
    intensity = COALESCE($5, intensity),
    perceived_exertion = COALESCE($6, perceived_exertion),
    duration_minutes = COALESCE($7, duration_minutes),
    steps_count = COALESCE($8, steps_count),
    pre_activity_carbs = COALESCE($9, pre_activity_carbs),
    water_intake_ml = COALESCE($10, water_intake_ml),
    issue_description = COALESCE($11, issue_description),
    source = COALESCE($12, source),
    sync_id = COALESCE($13, sync_id),
    notes = COALESCE($14, notes)
WHERE 
    activity_id = $1 AND user_id = $2
RETURNING activity_id, user_id, activity_timestamp, activity_code, intensity, perceived_exertion, duration_minutes, steps_count, pre_activity_carbs, water_intake_ml, issue_description, source, sync_id, notes, created_at, updated_at
`

type UpdateActivityLogParams struct {
	ActivityID        pgtype.UUID        `json:"activity_id"`
	UserID            string             `json:"user_id"`
	ActivityTimestamp pgtype.Timestamptz `json:"activity_timestamp"`
	ActivityCode      pgtype.Text        `json:"activity_code"`
	Intensity         pgtype.Text        `json:"intensity"`
	PerceivedExertion pgtype.Int4        `json:"perceived_exertion"`
	DurationMinutes   pgtype.Int4        `json:"duration_minutes"`
	StepsCount        pgtype.Int4        `json:"steps_count"`
	PreActivityCarbs  pgtype.Int4        `json:"pre_activity_carbs"`
	WaterIntakeMl     pgtype.Int4        `json:"water_intake_ml"`
	IssueDescription  pgtype.Text        `json:"issue_description"`
	Source            pgtype.Text        `json:"source"`
	SyncID            pgtype.Text        `json:"sync_id"`
	Notes             pgtype.Text        `json:"notes"`
}

// Updates an existing activity log, checking for user ownership
func (q *Queries) UpdateActivityLog(ctx context.Context, arg UpdateActivityLogParams) (UserActivityLog, error) {
	row := q.db.QueryRow(ctx, updateActivityLog,
		arg.ActivityID,
		arg.UserID,
		arg.ActivityTimestamp,
		arg.ActivityCode,
		arg.Intensity,
		arg.PerceivedExertion,
		arg.DurationMinutes,
		arg.StepsCount,
		arg.PreActivityCarbs,
		arg.WaterIntakeMl,
		arg.IssueDescription,
		arg.Source,
		arg.SyncID,
		arg.Notes,
	)
	var i UserActivityLog
	err := row.Scan(
		&i.ActivityID,
		&i.UserID,
		&i.ActivityTimestamp,
		&i.ActivityCode,
		&i.Intensity,
		&i.PerceivedExertion,
		&i.DurationMinutes,
		&i.StepsCount,
		&i.PreActivityCarbs,
		&i.WaterIntakeMl,
		&i.IssueDescription,
		&i.Source,
		&i.SyncID,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCartItemQuantity = `-- name: UpdateCartItemQuantity :one
UPDATE user_cart_items
SET quantity = $3
WHERE cart_id = $1 AND food_id = $2
RETURNING cart_item_id, cart_id, food_id, quantity
`

type UpdateCartItemQuantityParams struct {
	CartID   pgtype.UUID `json:"cart_id"`
	FoodID   pgtype.UUID `json:"food_id"`
	Quantity int32       `json:"quantity"`
}

func (q *Queries) UpdateCartItemQuantity(ctx context.Context, arg UpdateCartItemQuantityParams) (UserCartItem, error) {
	row := q.db.QueryRow(ctx, updateCartItemQuantity, arg.CartID, arg.FoodID, arg.Quantity)
	var i UserCartItem
	err := row.Scan(
		&i.CartItemID,
		&i.CartID,
		&i.FoodID,
		&i.Quantity,
	)
	return i, err
}

const updateGlucoseReading = `-- name: UpdateGlucoseReading :one
UPDATE user_glucose_readings
SET
    glucose_value = COALESCE($3, glucose_value),
    reading_timestamp = COALESCE($4, reading_timestamp),
    reading_type = COALESCE($5, reading_type),
    source = COALESCE($6, source),
    device_id = COALESCE($7, device_id),
    device_name = COALESCE($8, device_name),
    is_flagged = COALESCE($9, is_flagged),
    flag_reason = COALESCE($10, flag_reason),
    is_outlier = COALESCE($11, is_outlier),
    notes = COALESCE($12, notes),
    symptoms = COALESCE($13, symptoms)
WHERE 
    reading_id = $1 AND user_id = $2
RETURNING reading_id, user_id, glucose_value, reading_timestamp, reading_type, trend_arrow, rate_of_change, source, device_id, device_name, is_flagged, flag_reason, is_outlier, notes, symptoms, created_at, updated_at
`

type UpdateGlucoseReadingParams struct {
	ReadingID        pgtype.UUID        `json:"reading_id"`
	UserID           string             `json:"user_id"`
	GlucoseValue     int32              `json:"glucose_value"`
	ReadingTimestamp pgtype.Timestamptz `json:"reading_timestamp"`
	ReadingType      string             `json:"reading_type"`
	Source           pgtype.Text        `json:"source"`
	DeviceID         pgtype.Text        `json:"device_id"`
	DeviceName       pgtype.Text        `json:"device_name"`
	IsFlagged        pgtype.Bool        `json:"is_flagged"`
	FlagReason       pgtype.Text        `json:"flag_reason"`
	IsOutlier        pgtype.Bool        `json:"is_outlier"`
	Notes            pgtype.Text        `json:"notes"`
	Symptoms         []string           `json:"symptoms"`
}

// Updates an existing reading, checking for user ownership
func (q *Queries) UpdateGlucoseReading(ctx context.Context, arg UpdateGlucoseReadingParams) (UserGlucoseReading, error) {
	row := q.db.QueryRow(ctx, updateGlucoseReading,
		arg.ReadingID,
		arg.UserID,
		arg.GlucoseValue,
		arg.ReadingTimestamp,
		arg.ReadingType,
		arg.Source,
		arg.DeviceID,
		arg.DeviceName,
		arg.IsFlagged,
		arg.FlagReason,
		arg.IsOutlier,
		arg.Notes,
		arg.Symptoms,
	)
	var i UserGlucoseReading
	err := row.Scan(
		&i.ReadingID,
		&i.UserID,
		&i.GlucoseValue,
		&i.ReadingTimestamp,
		&i.ReadingType,
		&i.TrendArrow,
		&i.RateOfChange,
		&i.Source,
		&i.DeviceID,
		&i.DeviceName,
		&i.IsFlagged,
		&i.FlagReason,
		&i.IsOutlier,
		&i.Notes,
		&i.Symptoms,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHBA1CRecord = `-- name: UpdateHBA1CRecord :one
UPDATE user_hba1c_records
SET
    test_date = COALESCE($3, test_date),
    hba1c_percentage = COALESCE($4, hba1c_percentage),
    hba1c_mmol_mol = COALESCE($5, hba1c_mmol_mol),
    estimated_avg_glucose = COALESCE($6, estimated_avg_glucose),
    treatment_changed = COALESCE($7, treatment_changed),
    medication_changes = COALESCE($8, medication_changes),
    diet_changes = COALESCE($9, diet_changes),
    activity_changes = COALESCE($10, activity_changes),
    notes = COALESCE($11, notes),
    document_url = COALESCE($12, document_url),
    trend = COALESCE($13, trend) -- Trend will be calculated on the client/server
WHERE 
    hba1c_id = $1 AND user_id = $2
RETURNING hba1c_id, user_id, test_date, hba1c_percentage, hba1c_mmol_mol, estimated_avg_glucose, treatment_changed, medication_changes, diet_changes, activity_changes, change_from_previous, trend, notes, document_url, created_at, updated_at
`

type UpdateHBA1CRecordParams struct {
	Hba1cID             pgtype.UUID    `json:"hba1c_id"`
	UserID              string         `json:"user_id"`
	TestDate            pgtype.Date    `json:"test_date"`
	Hba1cPercentage     pgtype.Numeric `json:"hba1c_percentage"`
	Hba1cMmolMol        pgtype.Int4    `json:"hba1c_mmol_mol"`
	EstimatedAvgGlucose pgtype.Int4    `json:"estimated_avg_glucose"`
	TreatmentChanged    pgtype.Bool    `json:"treatment_changed"`
	MedicationChanges   pgtype.Text    `json:"medication_changes"`
	DietChanges         pgtype.Text    `json:"diet_changes"`
	ActivityChanges     pgtype.Text    `json:"activity_changes"`
	Notes               pgtype.Text    `json:"notes"`
	DocumentUrl         pgtype.Text    `json:"document_url"`
	Trend               pgtype.Text    `json:"trend"`
}

// Updates an existing record, checking for user ownership
func (q *Queries) UpdateHBA1CRecord(ctx context.Context, arg UpdateHBA1CRecordParams) (UserHba1cRecord, error) {
	row := q.db.QueryRow(ctx, updateHBA1CRecord,
		arg.Hba1cID,
		arg.UserID,
		arg.TestDate,
		arg.Hba1cPercentage,
		arg.Hba1cMmolMol,
		arg.EstimatedAvgGlucose,
		arg.TreatmentChanged,
		arg.MedicationChanges,
		arg.DietChanges,
		arg.ActivityChanges,
		arg.Notes,
		arg.DocumentUrl,
		arg.Trend,
	)
	var i UserHba1cRecord
	err := row.Scan(
		&i.Hba1cID,
		&i.UserID,
		&i.TestDate,
		&i.Hba1cPercentage,
		&i.Hba1cMmolMol,
		&i.EstimatedAvgGlucose,
		&i.TreatmentChanged,
		&i.MedicationChanges,
		&i.DietChanges,
		&i.ActivityChanges,
		&i.ChangeFromPrevious,
		&i.Trend,
		&i.Notes,
		&i.DocumentUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHealthEvent = `-- name: UpdateHealthEvent :one
UPDATE user_health_events
SET
    event_date = COALESCE($3, event_date),
    event_type = COALESCE($4, event_type),
    severity = COALESCE($5, severity),
    glucose_value = COALESCE($6, glucose_value),
    ketone_value_mmol = COALESCE($7, ketone_value_mmol),
    symptoms = COALESCE($8, symptoms),
    treatments = COALESCE($9, treatments),
    required_medical_attention = COALESCE($10, required_medical_attention),
    notes = COALESCE($11, notes)
WHERE 
    event_id = $1 AND user_id = $2
RETURNING event_id, user_id, event_date, event_type, severity, glucose_value, ketone_value_mmol, symptoms, treatments, required_medical_attention, notes, created_at, updated_at
`

type UpdateHealthEventParams struct {
	EventID                  pgtype.UUID    `json:"event_id"`
	UserID                   string         `json:"user_id"`
	EventDate                pgtype.Date    `json:"event_date"`
	EventType                string         `json:"event_type"`
	Severity                 pgtype.Text    `json:"severity"`
	GlucoseValue             pgtype.Int4    `json:"glucose_value"`
	KetoneValueMmol          pgtype.Numeric `json:"ketone_value_mmol"`
	Symptoms                 []string       `json:"symptoms"`
	Treatments               []string       `json:"treatments"`
	RequiredMedicalAttention pgtype.Bool    `json:"required_medical_attention"`
	Notes                    pgtype.Text    `json:"notes"`
}

// Updates an existing record, checking for user ownership
func (q *Queries) UpdateHealthEvent(ctx context.Context, arg UpdateHealthEventParams) (UserHealthEvent, error) {
	row := q.db.QueryRow(ctx, updateHealthEvent,
		arg.EventID,
		arg.UserID,
		arg.EventDate,
		arg.EventType,
		arg.Severity,
		arg.GlucoseValue,
		arg.KetoneValueMmol,
		arg.Symptoms,
		arg.Treatments,
		arg.RequiredMedicalAttention,
		arg.Notes,
	)
	var i UserHealthEvent
	err := row.Scan(
		&i.EventID,
		&i.UserID,
		&i.EventDate,
		&i.EventType,
		&i.Severity,
		&i.GlucoseValue,
		&i.KetoneValueMmol,
		&i.Symptoms,
		&i.Treatments,
		&i.RequiredMedicalAttention,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMealLog = `-- name: UpdateMealLog :one
UPDATE user_meal_logs
SET
    meal_timestamp = COALESCE($3, meal_timestamp),
    meal_type_id = COALESCE($4, meal_type_id),
    description = COALESCE($5, description),
    total_calories = COALESCE($6, total_calories),
    total_carbs_grams = COALESCE($7, total_carbs_grams),
    total_protein_grams = COALESCE($8, total_protein_grams),
    total_fat_grams = COALESCE($9, total_fat_grams),
    total_fiber_grams = COALESCE($10, total_fiber_grams),
    total_sugar_grams = COALESCE($11, total_sugar_grams),
    tags = COALESCE($12, tags)
WHERE 
    meal_id = $1 AND user_id = $2
RETURNING meal_id, user_id, meal_timestamp, meal_type_id, description, total_calories, total_carbs_grams, total_protein_grams, total_fat_grams, total_fiber_grams, total_sugar_grams, tags, created_at, updated_at
`

type UpdateMealLogParams struct {
	MealID            pgtype.UUID        `json:"meal_id"`
	UserID            string             `json:"user_id"`
	MealTimestamp     pgtype.Timestamptz `json:"meal_timestamp"`
	MealTypeID        pgtype.Int4        `json:"meal_type_id"`
	Description       pgtype.Text        `json:"description"`
	TotalCalories     pgtype.Int4        `json:"total_calories"`
	TotalCarbsGrams   pgtype.Numeric     `json:"total_carbs_grams"`
	TotalProteinGrams pgtype.Numeric     `json:"total_protein_grams"`
	TotalFatGrams     pgtype.Numeric     `json:"total_fat_grams"`
	TotalFiberGrams   pgtype.Numeric     `json:"total_fiber_grams"`
	TotalSugarGrams   pgtype.Numeric     `json:"total_sugar_grams"`
	Tags              []string           `json:"tags"`
}

func (q *Queries) UpdateMealLog(ctx context.Context, arg UpdateMealLogParams) (UserMealLog, error) {
	row := q.db.QueryRow(ctx, updateMealLog,
		arg.MealID,
		arg.UserID,
		arg.MealTimestamp,
		arg.MealTypeID,
		arg.Description,
		arg.TotalCalories,
		arg.TotalCarbsGrams,
		arg.TotalProteinGrams,
		arg.TotalFatGrams,
		arg.TotalFiberGrams,
		arg.TotalSugarGrams,
		arg.Tags,
	)
	var i UserMealLog
	err := row.Scan(
		&i.MealID,
		&i.UserID,
		&i.MealTimestamp,
		&i.MealTypeID,
		&i.Description,
		&i.TotalCalories,
		&i.TotalCarbsGrams,
		&i.TotalProteinGrams,
		&i.TotalFatGrams,
		&i.TotalFiberGrams,
		&i.TotalSugarGrams,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMedicationLog = `-- name: UpdateMedicationLog :one
UPDATE user_medication_logs
SET
    medication_id = COALESCE($3, medication_id),
    medication_name = COALESCE($4, medication_name),
    "timestamp" = COALESCE($5, "timestamp"),
    dose_amount = COALESCE($6, dose_amount),
    reason = COALESCE($7, reason),
    is_pump_delivery = COALESCE($8, is_pump_delivery),
    delivery_duration_minutes = COALESCE($9, delivery_duration_minutes),
    notes = COALESCE($10, notes)
WHERE
    medicationlog_id = $1 AND user_id = $2
RETURNING medicationlog_id, user_id, medication_id, medication_name, timestamp, dose_amount, reason, is_pump_delivery, delivery_duration_minutes, notes, created_at, updated_at
`

type UpdateMedicationLogParams struct {
	MedicationlogID         pgtype.UUID        `json:"medicationlog_id"`
	UserID                  string             `json:"user_id"`
	MedicationID            pgtype.Int4        `json:"medication_id"`
	MedicationName          pgtype.Text        `json:"medication_name"`
	Timestamp               pgtype.Timestamptz `json:"timestamp"`
	DoseAmount              pgtype.Numeric     `json:"dose_amount"`
	Reason                  pgtype.Text        `json:"reason"`
	IsPumpDelivery          pgtype.Bool        `json:"is_pump_delivery"`
	DeliveryDurationMinutes pgtype.Int4        `json:"delivery_duration_minutes"`
	Notes                   pgtype.Text        `json:"notes"`
}

// Updates a single logged dose.
func (q *Queries) UpdateMedicationLog(ctx context.Context, arg UpdateMedicationLogParams) (UserMedicationLog, error) {
	row := q.db.QueryRow(ctx, updateMedicationLog,
		arg.MedicationlogID,
		arg.UserID,
		arg.MedicationID,
		arg.MedicationName,
		arg.Timestamp,
		arg.DoseAmount,
		arg.Reason,
		arg.IsPumpDelivery,
		arg.DeliveryDurationMinutes,
		arg.Notes,
	)
	var i UserMedicationLog
	err := row.Scan(
		&i.MedicationlogID,
		&i.UserID,
		&i.MedicationID,
		&i.MedicationName,
		&i.Timestamp,
		&i.DoseAmount,
		&i.Reason,
		&i.IsPumpDelivery,
		&i.DeliveryDurationMinutes,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOTPAttempts = `-- name: UpdateOTPAttempts :exec
UPDATE otp_codes
SET otp_attempts = otp_attempts + 1
WHERE otp_id = $1
`

func (q *Queries) UpdateOTPAttempts(ctx context.Context, otpID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateOTPAttempts, otpID)
	return err
}

const updateRefreshTokenReplacement = `-- name: UpdateRefreshTokenReplacement :exec
UPDATE users_refresh_tokens
SET replaced_by_token_id = $2
WHERE id = $1
`

type UpdateRefreshTokenReplacementParams struct {
	ID                pgtype.UUID `json:"id"`
	ReplacedByTokenID pgtype.UUID `json:"replaced_by_token_id"`
}

func (q *Queries) UpdateRefreshTokenReplacement(ctx context.Context, arg UpdateRefreshTokenReplacementParams) error {
	_, err := q.db.Exec(ctx, updateRefreshTokenReplacement, arg.ID, arg.ReplacedByTokenID)
	return err
}

const updateSleepLog = `-- name: UpdateSleepLog :one
UPDATE user_sleep_logs
SET
    sleep_date = COALESCE($3, sleep_date),
    bed_time = COALESCE($4, bed_time),
    wake_time = COALESCE($5, wake_time),
    quality_rating = COALESCE($6, quality_rating),
    tracker_score = COALESCE($7, tracker_score),
    deep_sleep_minutes = COALESCE($8, deep_sleep_minutes),
    rem_sleep_minutes = COALESCE($9, rem_sleep_minutes),
    light_sleep_minutes = COALESCE($10, light_sleep_minutes),
    awake_minutes = COALESCE($11, awake_minutes),
    average_hrv = COALESCE($12, average_hrv),
    resting_heart_rate = COALESCE($13, resting_heart_rate),
    tags = COALESCE($14, tags),
    source = COALESCE($15, source),
    notes = COALESCE($16, notes)
WHERE 
    sleep_id = $1 AND user_id = $2
RETURNING sleep_id, user_id, sleep_date, bed_time, wake_time, quality_rating, tracker_score, deep_sleep_minutes, rem_sleep_minutes, light_sleep_minutes, awake_minutes, average_hrv, resting_heart_rate, tags, source, notes, created_at, updated_at
`

type UpdateSleepLogParams struct {
	SleepID           pgtype.UUID        `json:"sleep_id"`
	UserID            string             `json:"user_id"`
	SleepDate         pgtype.Date        `json:"sleep_date"`
	BedTime           pgtype.Timestamptz `json:"bed_time"`
	WakeTime          pgtype.Timestamptz `json:"wake_time"`
	QualityRating     pgtype.Int4        `json:"quality_rating"`
	TrackerScore      pgtype.Int4        `json:"tracker_score"`
	DeepSleepMinutes  pgtype.Int4        `json:"deep_sleep_minutes"`
	RemSleepMinutes   pgtype.Int4        `json:"rem_sleep_minutes"`
	LightSleepMinutes pgtype.Int4        `json:"light_sleep_minutes"`
	AwakeMinutes      pgtype.Int4        `json:"awake_minutes"`
	AverageHrv        pgtype.Int4        `json:"average_hrv"`
	RestingHeartRate  pgtype.Int4        `json:"resting_heart_rate"`
	Tags              []string           `json:"tags"`
	Source            pgtype.Text        `json:"source"`
	Notes             pgtype.Text        `json:"notes"`
}

// Updates an existing sleep log, checking for user ownership
func (q *Queries) UpdateSleepLog(ctx context.Context, arg UpdateSleepLogParams) (UserSleepLog, error) {
	row := q.db.QueryRow(ctx, updateSleepLog,
		arg.SleepID,
		arg.UserID,
		arg.SleepDate,
		arg.BedTime,
		arg.WakeTime,
		arg.QualityRating,
		arg.TrackerScore,
		arg.DeepSleepMinutes,
		arg.RemSleepMinutes,
		arg.LightSleepMinutes,
		arg.AwakeMinutes,
		arg.AverageHrv,
		arg.RestingHeartRate,
		arg.Tags,
		arg.Source,
		arg.Notes,
	)
	var i UserSleepLog
	err := row.Scan(
		&i.SleepID,
		&i.UserID,
		&i.SleepDate,
		&i.BedTime,
		&i.WakeTime,
		&i.QualityRating,
		&i.TrackerScore,
		&i.DeepSleepMinutes,
		&i.RemSleepMinutes,
		&i.LightSleepMinutes,
		&i.AwakeMinutes,
		&i.AverageHrv,
		&i.RestingHeartRate,
		&i.Tags,
		&i.Source,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserAddress = `-- name: UpdateUserAddress :one
UPDATE user_addresses
SET 
    address_line1 = COALESCE($3, address_line1),
    address_line2 = COALESCE($4, address_line2),
    address_district = COALESCE($5, address_district),
    address_city = COALESCE($6, address_city),
    address_province = COALESCE($7, address_province),
    address_postalcode = COALESCE($8, address_postalcode),
    address_latitude = COALESCE($9, address_latitude),
    address_longitude = COALESCE($10, address_longitude),
    address_label = COALESCE($11, address_label),
    recipient_name = COALESCE($12, recipient_name),
    recipient_phone = COALESCE($13, recipient_phone),
    delivery_notes = COALESCE($14, delivery_notes)
WHERE address_id = $1 AND user_id = $2 AND is_active = true
RETURNING address_id, user_id, address_line1, address_line2, address_city, address_province, address_postalcode, address_latitude, address_longitude, address_label, recipient_name, recipient_phone, delivery_notes, is_default, is_active, created_at, updated_at, address_district
`

type UpdateUserAddressParams struct {
	AddressID         pgtype.UUID   `json:"address_id"`
	UserID            string        `json:"user_id"`
	AddressLine1      pgtype.Text   `json:"address_line1"`
	AddressLine2      pgtype.Text   `json:"address_line2"`
	AddressDistrict   pgtype.Text   `json:"address_district"`
	AddressCity       pgtype.Text   `json:"address_city"`
	AddressProvince   pgtype.Text   `json:"address_province"`
	AddressPostalcode pgtype.Text   `json:"address_postalcode"`
	AddressLatitude   pgtype.Float8 `json:"address_latitude"`
	AddressLongitude  pgtype.Float8 `json:"address_longitude"`
	AddressLabel      pgtype.Text   `json:"address_label"`
	RecipientName     pgtype.Text   `json:"recipient_name"`
	RecipientPhone    pgtype.Text   `json:"recipient_phone"`
	DeliveryNotes     pgtype.Text   `json:"delivery_notes"`
}

func (q *Queries) UpdateUserAddress(ctx context.Context, arg UpdateUserAddressParams) (UserAddress, error) {
	row := q.db.QueryRow(ctx, updateUserAddress,
		arg.AddressID,
		arg.UserID,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.AddressDistrict,
		arg.AddressCity,
		arg.AddressProvince,
		arg.AddressPostalcode,
		arg.AddressLatitude,
		arg.AddressLongitude,
		arg.AddressLabel,
		arg.RecipientName,
		arg.RecipientPhone,
		arg.DeliveryNotes,
	)
	var i UserAddress
	err := row.Scan(
		&i.AddressID,
		&i.UserID,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.AddressCity,
		&i.AddressProvince,
		&i.AddressPostalcode,
		&i.AddressLatitude,
		&i.AddressLongitude,
		&i.AddressLabel,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.DeliveryNotes,
		&i.IsDefault,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressDistrict,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users
SET user_email = $2
WHERE user_id = $1
`

type UpdateUserEmailParams struct {
	UserID    string      `json:"user_id"`
	UserEmail pgtype.Text `json:"user_email"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.UserID, arg.UserEmail)
	return err
}

const updateUserGoogleLink = `-- name: UpdateUserGoogleLink :exec
UPDATE users
SET 
  user_name_auth = $1,
  user_avatar_url = $2,
  user_provider = $3,
  user_provider_user_id = $4,
  user_raw_data = $5,
  user_email_auth = $6
WHERE 
  user_id = $7
`

type UpdateUserGoogleLinkParams struct {
	UserNameAuth       pgtype.Text `json:"user_name_auth"`
	UserAvatarUrl      pgtype.Text `json:"user_avatar_url"`
	UserProvider       pgtype.Text `json:"user_provider"`
	UserProviderUserID pgtype.Text `json:"user_provider_user_id"`
	UserRawData        []byte      `json:"user_raw_data"`
	UserEmailAuth      pgtype.Text `json:"user_email_auth"`
	UserID             string      `json:"user_id"`
}

func (q *Queries) UpdateUserGoogleLink(ctx context.Context, arg UpdateUserGoogleLinkParams) error {
	_, err := q.db.Exec(ctx, updateUserGoogleLink,
		arg.UserNameAuth,
		arg.UserAvatarUrl,
		arg.UserProvider,
		arg.UserProviderUserID,
		arg.UserRawData,
		arg.UserEmailAuth,
		arg.UserID,
	)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET user_last_login_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, userID)
	return err
}

const updateUserMedication = `-- name: UpdateUserMedication :one
UPDATE user_medications
SET
    display_name = COALESCE($3, display_name),
    medication_type = COALESCE($4, medication_type),
    default_dose_unit = COALESCE($5, default_dose_unit),
    is_active = COALESCE($6, is_active)
WHERE
    medication_id = $1 AND user_id = $2
RETURNING medication_id, user_id, display_name, medication_type, default_dose_unit, is_active, created_at, updated_at
`

type UpdateUserMedicationParams struct {
	MedicationID    int32       `json:"medication_id"`
	UserID          pgtype.Text `json:"user_id"`
	DisplayName     pgtype.Text `json:"display_name"`
	MedicationType  pgtype.Text `json:"medication_type"`
	DefaultDoseUnit pgtype.Text `json:"default_dose_unit"`
	IsActive        pgtype.Bool `json:"is_active"`
}

// Updates the configuration of an existing medication.
func (q *Queries) UpdateUserMedication(ctx context.Context, arg UpdateUserMedicationParams) (UserMedication, error) {
	row := q.db.QueryRow(ctx, updateUserMedication,
		arg.MedicationID,
		arg.UserID,
		arg.DisplayName,
		arg.MedicationType,
		arg.DefaultDoseUnit,
		arg.IsActive,
	)
	var i UserMedication
	err := row.Scan(
		&i.MedicationID,
		&i.UserID,
		&i.DisplayName,
		&i.MedicationType,
		&i.DefaultDoseUnit,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET user_password = $2
WHERE user_id = $1
`

type UpdateUserPasswordParams struct {
	UserID       string      `json:"user_id"`
	UserPassword pgtype.Text `json:"user_password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.UserID, arg.UserPassword)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET 
    user_firstname = COALESCE($2, user_firstname),
    user_lastname = COALESCE($3, user_lastname),
    user_email = COALESCE($4, user_email),
    user_dob = COALESCE($5, user_dob),
    user_gender = COALESCE($6, user_gender)
WHERE user_id = $1
RETURNING user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at
`

type UpdateUserProfileParams struct {
	UserID        string              `json:"user_id"`
	UserFirstname pgtype.Text         `json:"user_firstname"`
	UserLastname  pgtype.Text         `json:"user_lastname"`
	UserEmail     pgtype.Text         `json:"user_email"`
	UserDob       pgtype.Date         `json:"user_dob"`
	UserGender    NullUsersUserGender `json:"user_gender"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.UserID,
		arg.UserFirstname,
		arg.UserLastname,
		arg.UserEmail,
		arg.UserDob,
		arg.UserGender,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const updateUserUsername = `-- name: UpdateUserUsername :exec
UPDATE users
SET user_username = $2
WHERE user_id = $1
`

type UpdateUserUsernameParams struct {
	UserID       string      `json:"user_id"`
	UserUsername pgtype.Text `json:"user_username"`
}

func (q *Queries) UpdateUserUsername(ctx context.Context, arg UpdateUserUsernameParams) error {
	_, err := q.db.Exec(ctx, updateUserUsername, arg.UserID, arg.UserUsername)
	return err
}

const upsertCartItem = `-- name: UpsertCartItem :one
INSERT INTO user_cart_items (
    cart_id,
    food_id,
    quantity
) VALUES (
    $1, $2, $3
)
ON CONFLICT (cart_id, food_id)
DO UPDATE SET
    quantity = user_cart_items.quantity + $3
RETURNING cart_item_id, cart_id, food_id, quantity
`

type UpsertCartItemParams struct {
	CartID   pgtype.UUID `json:"cart_id"`
	FoodID   pgtype.UUID `json:"food_id"`
	Quantity int32       `json:"quantity"`
}

// Adds an item to the cart, or increases its quantity if it already exists
func (q *Queries) UpsertCartItem(ctx context.Context, arg UpsertCartItemParams) (UserCartItem, error) {
	row := q.db.QueryRow(ctx, upsertCartItem, arg.CartID, arg.FoodID, arg.Quantity)
	var i UserCartItem
	err := row.Scan(
		&i.CartItemID,
		&i.CartID,
		&i.FoodID,
		&i.Quantity,
	)
	return i, err
}

const upsertOAuthUser = `-- name: UpsertOAuthUser :one
INSERT INTO users (
    user_id,
    user_email,
    user_name_auth,
    user_avatar_url,
    user_provider,
    user_provider_user_id,
    user_raw_data,
    user_last_login_at,
    user_email_auth,
    user_username,
    user_password
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
ON CONFLICT (user_provider, user_provider_user_id) 
DO UPDATE SET 
    -- Update fields based on EXCLUDED (the row that was attempted to be inserted)
    user_email = COALESCE(EXCLUDED.user_email, users.user_email),
    user_name_auth = EXCLUDED.user_name_auth,
    user_avatar_url = EXCLUDED.user_avatar_url,
    user_raw_data = EXCLUDED.user_raw_data,
    user_last_login_at = EXCLUDED.user_last_login_at
RETURNING user_id, user_username, user_password, user_firstname, user_lastname, user_email, user_dob, user_gender, user_accounttype, user_name_auth, user_avatar_url, user_provider, user_provider_user_id, user_raw_data, created_at, updated_at, user_last_login_at, user_email_auth, is_email_verified, email_verified_at
`

type UpsertOAuthUserParams struct {
	UserID             string             `json:"user_id"`
	UserEmail          pgtype.Text        `json:"user_email"`
	UserNameAuth       pgtype.Text        `json:"user_name_auth"`
	UserAvatarUrl      pgtype.Text        `json:"user_avatar_url"`
	UserProvider       pgtype.Text        `json:"user_provider"`
	UserProviderUserID pgtype.Text        `json:"user_provider_user_id"`
	UserRawData        []byte             `json:"user_raw_data"`
	UserLastLoginAt    pgtype.Timestamptz `json:"user_last_login_at"`
	UserEmailAuth      pgtype.Text        `json:"user_email_auth"`
	UserUsername       pgtype.Text        `json:"user_username"`
	UserPassword       pgtype.Text        `json:"user_password"`
}

// OAuth Integration - Upsert user with OAuth data
func (q *Queries) UpsertOAuthUser(ctx context.Context, arg UpsertOAuthUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertOAuthUser,
		arg.UserID,
		arg.UserEmail,
		arg.UserNameAuth,
		arg.UserAvatarUrl,
		arg.UserProvider,
		arg.UserProviderUserID,
		arg.UserRawData,
		arg.UserLastLoginAt,
		arg.UserEmailAuth,
		arg.UserUsername,
		arg.UserPassword,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.UserUsername,
		&i.UserPassword,
		&i.UserFirstname,
		&i.UserLastname,
		&i.UserEmail,
		&i.UserDob,
		&i.UserGender,
		&i.UserAccounttype,
		&i.UserNameAuth,
		&i.UserAvatarUrl,
		&i.UserProvider,
		&i.UserProviderUserID,
		&i.UserRawData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserLastLoginAt,
		&i.UserEmailAuth,
		&i.IsEmailVerified,
		&i.EmailVerifiedAt,
	)
	return i, err
}

const upsertUserHealthProfile = `-- name: UpsertUserHealthProfile :one
INSERT INTO user_health_profiles (
    user_id,
    app_experience,
    condition_id,
    diagnosis_date,
    years_with_condition,
    treatment_types,
    target_glucose_fasting,
    target_glucose_postprandial,
    uses_cgm,
    cgm_device,
    cgm_api_connected,
    height_cm,
    current_weight_kg,
    target_weight_kg,
    waist_circumference_cm,
    body_fat_percentage,
    hba1c_target,
    last_hba1c,
    last_hba1c_date,
    activity_level,
    daily_steps_goal,
    weekly_exercise_goal_minutes,
    preferred_activity_type_ids,
    dietary_pattern,
    daily_carb_target_grams,
    daily_calorie_target,
    daily_protein_target_grams,
    daily_fat_target_grams,
    meals_per_day,
    snacks_per_day,
    food_allergies,
    food_intolerances,
    foods_to_avoid,
    cultural_cuisines,
    dietary_restrictions,
    has_hypertension,
    hypertension_medication,
    has_kidney_disease,
    kidney_disease_stage,
    egfr_value,
    has_cardiovascular_disease,
    has_neuropathy,
    has_retinopathy,
    has_gastroparesis,
    has_hypoglycemia_unawareness,
    other_conditions,
    smoking_status,
    smoking_years,
    alcohol_frequency,
    alcohol_drinks_per_week,
    stress_level,
    typical_sleep_hours,
    sleep_quality,
    is_pregnant,
    is_breastfeeding,
    expected_due_date,
    preferred_units,
    glucose_unit,
    timezone,
    language_code,
    enable_glucose_alerts,
    enable_meal_reminders,
    enable_activity_reminders,
    enable_medication_reminders,
    share_data_for_research,
    share_anonymized_data
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66
)
ON CONFLICT (user_id) DO UPDATE SET
    app_experience = COALESCE($2, user_health_profiles.app_experience),
    condition_id = COALESCE($3, user_health_profiles.condition_id),
    diagnosis_date = COALESCE($4, user_health_profiles.diagnosis_date),
    years_with_condition = COALESCE($5, user_health_profiles.years_with_condition),
    treatment_types = COALESCE($6, user_health_profiles.treatment_types),
    target_glucose_fasting = COALESCE($7, user_health_profiles.target_glucose_fasting),
    target_glucose_postprandial = COALESCE($8, user_health_profiles.target_glucose_postprandial),
    uses_cgm = COALESCE($9, user_health_profiles.uses_cgm),
    cgm_device = COALESCE($10, user_health_profiles.cgm_device),
    cgm_api_connected = COALESCE($11, user_health_profiles.cgm_api_connected),
    height_cm = COALESCE($12, user_health_profiles.height_cm),
    current_weight_kg = COALESCE($13, user_health_profiles.current_weight_kg),
    target_weight_kg = COALESCE($14, user_health_profiles.target_weight_kg),
    waist_circumference_cm = COALESCE($15, user_health_profiles.waist_circumference_cm),
    body_fat_percentage = COALESCE($16, user_health_profiles.body_fat_percentage),
    hba1c_target = COALESCE($17, user_health_profiles.hba1c_target),
    last_hba1c = COALESCE($18, user_health_profiles.last_hba1c),
    last_hba1c_date = COALESCE($19, user_health_profiles.last_hba1c_date),
    activity_level = COALESCE($20, user_health_profiles.activity_level),
    daily_steps_goal = COALESCE($21, user_health_profiles.daily_steps_goal),
    weekly_exercise_goal_minutes = COALESCE($22, user_health_profiles.weekly_exercise_goal_minutes),
    preferred_activity_type_ids = COALESCE($23, user_health_profiles.preferred_activity_type_ids),
    dietary_pattern = COALESCE($24, user_health_profiles.dietary_pattern),
    daily_carb_target_grams = COALESCE($25, user_health_profiles.daily_carb_target_grams),
    daily_calorie_target = COALESCE($26, user_health_profiles.daily_calorie_target),
    daily_protein_target_grams = COALESCE($27, user_health_profiles.daily_protein_target_grams),
    daily_fat_target_grams = COALESCE($28, user_health_profiles.daily_fat_target_grams),
    meals_per_day = COALESCE($29, user_health_profiles.meals_per_day),
    snacks_per_day = COALESCE($30, user_health_profiles.snacks_per_day),
    food_allergies = COALESCE($31, user_health_profiles.food_allergies),
    food_intolerances = COALESCE($32, user_health_profiles.food_intolerances),
    foods_to_avoid = COALESCE($33, user_health_profiles.foods_to_avoid),
    cultural_cuisines = COALESCE($34, user_health_profiles.cultural_cuisines),
    dietary_restrictions = COALESCE($35, user_health_profiles.dietary_restrictions),
    has_hypertension = COALESCE($36, user_health_profiles.has_hypertension),
    hypertension_medication = COALESCE($37, user_health_profiles.hypertension_medication),
    has_kidney_disease = COALESCE($38, user_health_profiles.has_kidney_disease),
    kidney_disease_stage = COALESCE($39, user_health_profiles.kidney_disease_stage),
    egfr_value = COALESCE($40, user_health_profiles.egfr_value),
    has_cardiovascular_disease = COALESCE($41, user_health_profiles.has_cardiovascular_disease),
    has_neuropathy = COALESCE($42, user_health_profiles.has_neuropathy),
    has_retinopathy = COALESCE($43, user_health_profiles.has_retinopathy),
    has_gastroparesis = COALESCE($44, user_health_profiles.has_gastroparesis),
    has_hypoglycemia_unawareness = COALESCE($45, user_health_profiles.has_hypoglycemia_unawareness),
    other_conditions = COALESCE($46, user_health_profiles.other_conditions),
    smoking_status = COALESCE($47, user_health_profiles.smoking_status),
    smoking_years = COALESCE($48, user_health_profiles.smoking_years),
    alcohol_frequency = COALESCE($49, user_health_profiles.alcohol_frequency),
    alcohol_drinks_per_week = COALESCE($50, user_health_profiles.alcohol_drinks_per_week),
    stress_level = COALESCE($51, user_health_profiles.stress_level),
    typical_sleep_hours = COALESCE($52, user_health_profiles.typical_sleep_hours),
    sleep_quality = COALESCE($53, user_health_profiles.sleep_quality),
    is_pregnant = COALESCE($54, user_health_profiles.is_pregnant),
    is_breastfeeding = COALESCE($55, user_health_profiles.is_breastfeeding),
    expected_due_date = COALESCE($56, user_health_profiles.expected_due_date),
    preferred_units = COALESCE($57, user_health_profiles.preferred_units),
    glucose_unit = COALESCE($58, user_health_profiles.glucose_unit),
    timezone = COALESCE($59, user_health_profiles.timezone),
    language_code = COALESCE($60, user_health_profiles.language_code),
    enable_glucose_alerts = COALESCE($61, user_health_profiles.enable_glucose_alerts),
    enable_meal_reminders = COALESCE($62, user_health_profiles.enable_meal_reminders),
    enable_activity_reminders = COALESCE($63, user_health_profiles.enable_activity_reminders),
    enable_medication_reminders = COALESCE($64, user_health_profiles.enable_medication_reminders),
    share_data_for_research = COALESCE($65, user_health_profiles.share_data_for_research),
    share_anonymized_data = COALESCE($66, user_health_profiles.share_anonymized_data)
RETURNING profile_id, user_id, app_experience, condition_id, diagnosis_date, years_with_condition, treatment_types, target_glucose_fasting, target_glucose_postprandial, uses_cgm, cgm_device, cgm_api_connected, height_cm, current_weight_kg, target_weight_kg, bmi, waist_circumference_cm, body_fat_percentage, hba1c_target, last_hba1c, last_hba1c_date, activity_level, daily_steps_goal, weekly_exercise_goal_minutes, preferred_activity_type_ids, dietary_pattern, daily_carb_target_grams, daily_calorie_target, daily_protein_target_grams, daily_fat_target_grams, meals_per_day, snacks_per_day, food_allergies, food_intolerances, foods_to_avoid, cultural_cuisines, dietary_restrictions, has_hypertension, hypertension_medication, has_kidney_disease, kidney_disease_stage, egfr_value, has_cardiovascular_disease, has_neuropathy, has_retinopathy, has_gastroparesis, has_hypoglycemia_unawareness, other_conditions, smoking_status, smoking_years, alcohol_frequency, alcohol_drinks_per_week, stress_level, typical_sleep_hours, sleep_quality, is_pregnant, is_breastfeeding, expected_due_date, preferred_units, glucose_unit, timezone, language_code, enable_glucose_alerts, enable_meal_reminders, enable_activity_reminders, enable_medication_reminders, share_data_for_research, share_anonymized_data, created_at, updated_at
`

type UpsertUserHealthProfileParams struct {
	UserID                     string         `json:"user_id"`
	AppExperience              string         `json:"app_experience"`
	ConditionID                int32          `json:"condition_id"`
	DiagnosisDate              pgtype.Date    `json:"diagnosis_date"`
	YearsWithCondition         pgtype.Numeric `json:"years_with_condition"`
	TreatmentTypes             []string       `json:"treatment_types"`
	TargetGlucoseFasting       pgtype.Int4    `json:"target_glucose_fasting"`
	TargetGlucosePostprandial  pgtype.Int4    `json:"target_glucose_postprandial"`
	UsesCgm                    pgtype.Bool    `json:"uses_cgm"`
	CgmDevice                  pgtype.Text    `json:"cgm_device"`
	CgmApiConnected            pgtype.Bool    `json:"cgm_api_connected"`
	HeightCm                   pgtype.Numeric `json:"height_cm"`
	CurrentWeightKg            pgtype.Numeric `json:"current_weight_kg"`
	TargetWeightKg             pgtype.Numeric `json:"target_weight_kg"`
	WaistCircumferenceCm       pgtype.Numeric `json:"waist_circumference_cm"`
	BodyFatPercentage          pgtype.Numeric `json:"body_fat_percentage"`
	Hba1cTarget                pgtype.Numeric `json:"hba1c_target"`
	LastHba1c                  pgtype.Numeric `json:"last_hba1c"`
	LastHba1cDate              pgtype.Date    `json:"last_hba1c_date"`
	ActivityLevel              pgtype.Text    `json:"activity_level"`
	DailyStepsGoal             pgtype.Int4    `json:"daily_steps_goal"`
	WeeklyExerciseGoalMinutes  pgtype.Int4    `json:"weekly_exercise_goal_minutes"`
	PreferredActivityTypeIds   []int32        `json:"preferred_activity_type_ids"`
	DietaryPattern             pgtype.Text    `json:"dietary_pattern"`
	DailyCarbTargetGrams       pgtype.Int4    `json:"daily_carb_target_grams"`
	DailyCalorieTarget         pgtype.Int4    `json:"daily_calorie_target"`
	DailyProteinTargetGrams    pgtype.Int4    `json:"daily_protein_target_grams"`
	DailyFatTargetGrams        pgtype.Int4    `json:"daily_fat_target_grams"`
	MealsPerDay                pgtype.Int4    `json:"meals_per_day"`
	SnacksPerDay               pgtype.Int4    `json:"snacks_per_day"`
	FoodAllergies              []string       `json:"food_allergies"`
	FoodIntolerances           []string       `json:"food_intolerances"`
	FoodsToAvoid               []string       `json:"foods_to_avoid"`
	CulturalCuisines           []string       `json:"cultural_cuisines"`
	DietaryRestrictions        []string       `json:"dietary_restrictions"`
	HasHypertension            pgtype.Bool    `json:"has_hypertension"`
	HypertensionMedication     pgtype.Text    `json:"hypertension_medication"`
	HasKidneyDisease           pgtype.Bool    `json:"has_kidney_disease"`
	KidneyDiseaseStage         pgtype.Int4    `json:"kidney_disease_stage"`
	EgfrValue                  pgtype.Numeric `json:"egfr_value"`
	HasCardiovascularDisease   pgtype.Bool    `json:"has_cardiovascular_disease"`
	HasNeuropathy              pgtype.Bool    `json:"has_neuropathy"`
	HasRetinopathy             pgtype.Bool    `json:"has_retinopathy"`
	HasGastroparesis           pgtype.Bool    `json:"has_gastroparesis"`
	HasHypoglycemiaUnawareness pgtype.Bool    `json:"has_hypoglycemia_unawareness"`
	OtherConditions            []string       `json:"other_conditions"`
	SmokingStatus              pgtype.Text    `json:"smoking_status"`
	SmokingYears               pgtype.Int4    `json:"smoking_years"`
	AlcoholFrequency           pgtype.Text    `json:"alcohol_frequency"`
	AlcoholDrinksPerWeek       pgtype.Int4    `json:"alcohol_drinks_per_week"`
	StressLevel                pgtype.Text    `json:"stress_level"`
	TypicalSleepHours          pgtype.Numeric `json:"typical_sleep_hours"`
	SleepQuality               pgtype.Text    `json:"sleep_quality"`
	IsPregnant                 pgtype.Bool    `json:"is_pregnant"`
	IsBreastfeeding            pgtype.Bool    `json:"is_breastfeeding"`
	ExpectedDueDate            pgtype.Date    `json:"expected_due_date"`
	PreferredUnits             pgtype.Text    `json:"preferred_units"`
	GlucoseUnit                pgtype.Text    `json:"glucose_unit"`
	Timezone                   pgtype.Text    `json:"timezone"`
	LanguageCode               pgtype.Text    `json:"language_code"`
	EnableGlucoseAlerts        pgtype.Bool    `json:"enable_glucose_alerts"`
	EnableMealReminders        pgtype.Bool    `json:"enable_meal_reminders"`
	EnableActivityReminders    pgtype.Bool    `json:"enable_activity_reminders"`
	EnableMedicationReminders  pgtype.Bool    `json:"enable_medication_reminders"`
	ShareDataForResearch       pgtype.Bool    `json:"share_data_for_research"`
	ShareAnonymizedData        pgtype.Bool    `json:"share_anonymized_data"`
}

func (q *Queries) UpsertUserHealthProfile(ctx context.Context, arg UpsertUserHealthProfileParams) (UserHealthProfile, error) {
	row := q.db.QueryRow(ctx, upsertUserHealthProfile,
		arg.UserID,
		arg.AppExperience,
		arg.ConditionID,
		arg.DiagnosisDate,
		arg.YearsWithCondition,
		arg.TreatmentTypes,
		arg.TargetGlucoseFasting,
		arg.TargetGlucosePostprandial,
		arg.UsesCgm,
		arg.CgmDevice,
		arg.CgmApiConnected,
		arg.HeightCm,
		arg.CurrentWeightKg,
		arg.TargetWeightKg,
		arg.WaistCircumferenceCm,
		arg.BodyFatPercentage,
		arg.Hba1cTarget,
		arg.LastHba1c,
		arg.LastHba1cDate,
		arg.ActivityLevel,
		arg.DailyStepsGoal,
		arg.WeeklyExerciseGoalMinutes,
		arg.PreferredActivityTypeIds,
		arg.DietaryPattern,
		arg.DailyCarbTargetGrams,
		arg.DailyCalorieTarget,
		arg.DailyProteinTargetGrams,
		arg.DailyFatTargetGrams,
		arg.MealsPerDay,
		arg.SnacksPerDay,
		arg.FoodAllergies,
		arg.FoodIntolerances,
		arg.FoodsToAvoid,
		arg.CulturalCuisines,
		arg.DietaryRestrictions,
		arg.HasHypertension,
		arg.HypertensionMedication,
		arg.HasKidneyDisease,
		arg.KidneyDiseaseStage,
		arg.EgfrValue,
		arg.HasCardiovascularDisease,
		arg.HasNeuropathy,
		arg.HasRetinopathy,
		arg.HasGastroparesis,
		arg.HasHypoglycemiaUnawareness,
		arg.OtherConditions,
		arg.SmokingStatus,
		arg.SmokingYears,
		arg.AlcoholFrequency,
		arg.AlcoholDrinksPerWeek,
		arg.StressLevel,
		arg.TypicalSleepHours,
		arg.SleepQuality,
		arg.IsPregnant,
		arg.IsBreastfeeding,
		arg.ExpectedDueDate,
		arg.PreferredUnits,
		arg.GlucoseUnit,
		arg.Timezone,
		arg.LanguageCode,
		arg.EnableGlucoseAlerts,
		arg.EnableMealReminders,
		arg.EnableActivityReminders,
		arg.EnableMedicationReminders,
		arg.ShareDataForResearch,
		arg.ShareAnonymizedData,
	)
	var i UserHealthProfile
	err := row.Scan(
		&i.ProfileID,
		&i.UserID,
		&i.AppExperience,
		&i.ConditionID,
		&i.DiagnosisDate,
		&i.YearsWithCondition,
		&i.TreatmentTypes,
		&i.TargetGlucoseFasting,
		&i.TargetGlucosePostprandial,
		&i.UsesCgm,
		&i.CgmDevice,
		&i.CgmApiConnected,
		&i.HeightCm,
		&i.CurrentWeightKg,
		&i.TargetWeightKg,
		&i.Bmi,
		&i.WaistCircumferenceCm,
		&i.BodyFatPercentage,
		&i.Hba1cTarget,
		&i.LastHba1c,
		&i.LastHba1cDate,
		&i.ActivityLevel,
		&i.DailyStepsGoal,
		&i.WeeklyExerciseGoalMinutes,
		&i.PreferredActivityTypeIds,
		&i.DietaryPattern,
		&i.DailyCarbTargetGrams,
		&i.DailyCalorieTarget,
		&i.DailyProteinTargetGrams,
		&i.DailyFatTargetGrams,
		&i.MealsPerDay,
		&i.SnacksPerDay,
		&i.FoodAllergies,
		&i.FoodIntolerances,
		&i.FoodsToAvoid,
		&i.CulturalCuisines,
		&i.DietaryRestrictions,
		&i.HasHypertension,
		&i.HypertensionMedication,
		&i.HasKidneyDisease,
		&i.KidneyDiseaseStage,
		&i.EgfrValue,
		&i.HasCardiovascularDisease,
		&i.HasNeuropathy,
		&i.HasRetinopathy,
		&i.HasGastroparesis,
		&i.HasHypoglycemiaUnawareness,
		&i.OtherConditions,
		&i.SmokingStatus,
		&i.SmokingYears,
		&i.AlcoholFrequency,
		&i.AlcoholDrinksPerWeek,
		&i.StressLevel,
		&i.TypicalSleepHours,
		&i.SleepQuality,
		&i.IsPregnant,
		&i.IsBreastfeeding,
		&i.ExpectedDueDate,
		&i.PreferredUnits,
		&i.GlucoseUnit,
		&i.Timezone,
		&i.LanguageCode,
		&i.EnableGlucoseAlerts,
		&i.EnableMealReminders,
		&i.EnableActivityReminders,
		&i.EnableMedicationReminders,
		&i.ShareDataForResearch,
		&i.ShareAnonymizedData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyOTPAtomic = `-- name: VerifyOTPAtomic :one
SELECT verify_otp_atomic FROM verify_otp_atomic($1, $2)
`

type VerifyOTPAtomicParams struct {
	PEntityID    pgtype.UUID `json:"p_entity_id"`
	PMaxAttempts int32       `json:"p_max_attempts"`
}

func (q *Queries) VerifyOTPAtomic(ctx context.Context, arg VerifyOTPAtomicParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, verifyOTPAtomic, arg.PEntityID, arg.PMaxAttempts)
	var verify_otp_atomic interface{}
	err := row.Scan(&verify_otp_atomic)
	return verify_otp_atomic, err
}

const verifyUserEmail = `-- name: VerifyUserEmail :exec
UPDATE users
SET is_email_verified = $2,
    email_verified_at = $3
WHERE user_id = $1
`

type VerifyUserEmailParams struct {
	UserID          string             `json:"user_id"`
	IsEmailVerified pgtype.Bool        `json:"is_email_verified"`
	EmailVerifiedAt pgtype.Timestamptz `json:"email_verified_at"`
}

func (q *Queries) VerifyUserEmail(ctx context.Context, arg VerifyUserEmailParams) error {
	_, err := q.db.Exec(ctx, verifyUserEmail, arg.UserID, arg.IsEmailVerified, arg.EmailVerifiedAt)
	return err
}
